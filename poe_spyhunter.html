<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spy Hunter Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --road-color: #333333;
            --road-line-color: #FFFFFF;
            --grass-color: #228B22;
            --water-color: #1E90FF;
            --player-color: #5D5CDE;
            --enemy-color: #FF0000;
            --civilian-color: #FFFF00;
            --bullet-color: #FFFFFF;
            --oil-color: #000000;
            --smoke-color: #CCCCCC;
            --ui-bg: rgba(255, 255, 255, 0.8);
            --text-color: #000000;
        }

        .dark {
            --road-color: #1a1a1a;
            --road-line-color: #DDDDDD;
            --grass-color: #0e5c0e;
            --water-color: #0066cc;
            --player-color: #5D5CDE;
            --enemy-color: #FF3333;
            --civilian-color: #CCCC00;
            --bullet-color: #FFFFFF;
            --oil-color: #333333;
            --smoke-color: #999999;
            --ui-bg: rgba(30, 30, 30, 0.8);
            --text-color: #FFFFFF;
        }

        body {
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #gameControls button {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen flex flex-col items-center justify-start">
    <div class="w-full max-w-lg px-2 py-4">
        <h1 class="text-2xl font-bold text-center text-gray-900 dark:text-white mb-2">Spy Hunter</h1>
        
        <div id="gameContainer" class="relative w-full">
            <canvas id="gameCanvas" class="border-2 border-gray-300 dark:border-gray-700 w-full rounded-md shadow-md"></canvas>
            
            <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-white dark:bg-gray-900 bg-opacity-90 dark:bg-opacity-90 rounded-md">
                <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-4">SPY HUNTER</h2>
                <p class="text-gray-700 dark:text-gray-300 mb-6 text-center px-4">Drive your spy car, shoot enemies, and avoid civilians!</p>
                <button id="startButton" class="bg-primary hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded focus:outline-none">
                    START GAME
                </button>
                <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center px-4">
                    <p class="mb-2"><b>Controls:</b></p>
                    <p class="mb-1">Desktop: Arrow keys to move, Space to shoot</p>
                    <p>Mobile: On-screen controls appear during gameplay</p>
                </div>
            </div>
            
            <div id="gameOverScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-white dark:bg-gray-900 bg-opacity-90 dark:bg-opacity-90 rounded-md hidden">
                <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-2">GAME OVER</h2>
                <p id="finalScore" class="text-lg text-gray-800 dark:text-gray-200 mb-6"></p>
                <button id="restartButton" class="bg-primary hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded focus:outline-none">
                    PLAY AGAIN
                </button>
            </div>
            
            <div id="gameControls" class="absolute bottom-4 left-0 right-0 flex justify-between px-6 hidden">
                <div class="flex">
                    <button id="leftBtn" class="bg-gray-800 bg-opacity-60 text-white w-12 h-12 rounded-l-full flex items-center justify-center focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>
                    <button id="rightBtn" class="bg-gray-800 bg-opacity-60 text-white w-12 h-12 rounded-r-full flex items-center justify-center focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                </div>
                <button id="fireBtn" class="bg-red-600 bg-opacity-70 text-white w-16 h-16 rounded-full flex items-center justify-center focus:outline-none">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="flex justify-between mt-2 px-2">
            <div>
                <p class="text-sm text-gray-700 dark:text-gray-300">Score: <span id="scoreDisplay">0</span></p>
                <p class="text-sm text-gray-700 dark:text-gray-300">Lives: <span id="livesDisplay">3</span></p>
            </div>
            <div id="weaponStatus" class="text-sm text-gray-700 dark:text-gray-300">
                Weapon: Standard
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            document.documentElement.classList.toggle('dark', event.matches);
        });

        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const gameControls = document.getElementById('gameControls');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const finalScore = document.getElementById('finalScore');
        const weaponStatus = document.getElementById('weaponStatus');

        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const fireBtn = document.getElementById('fireBtn');

        // Game state
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let roadSpeed = 3;
        let roadPosition = 0;
        let roadWidth = 0;
        let roadLeftEdge = 0;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let lastTimestamp = 0;
        let difficulty = 1;
        let weaponType = "standard";
        let weaponTimer = 0;

        // Road elements
        let roadElements = [];

        // Player
        let player = {
            width: 30,
            height: 50,
            x: 0,
            y: 0,
            speed: 5,
            isShooting: false,
            cooldown: 0,
            maxCooldown: 10,
            isDamaged: false,
            damageTimer: 0,
            isInvulnerable: false,
            invulnerabilityTimer: 0
        };

        // Bullets
        let bullets = [];

        // Enemies and civilians
        let vehicles = [];

        // Effects
        let effects = [];

        // Controls state
        const controls = {
            left: false,
            right: false,
            up: false,
            down: false,
            fire: false
        };

        const touchStates = new Map();

        // Initialize game
        function initGame() {
            resizeCanvas();

            player.x = canvasWidth / 2 - player.width / 2;
            player.y = canvasHeight - player.height - 20;

            score = 0;
            lives = 3;
            roadSpeed = 3;
            roadPosition = 0;
            difficulty = 1;
            weaponType = "standard";
            weaponTimer = 0;
            roadElements = [];
            bullets = [];
            vehicles = [];
            effects = [];
            
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            weaponStatus.textContent = "Weapon: Standard";

            roadWidth = canvasWidth * 0.7;
            roadLeftEdge = (canvasWidth - roadWidth) / 2;

            createInitialRoadElements();

            gameRunning = true;
            lastTimestamp = performance.now();
            requestAnimationFrame(gameLoop);

            if (isMobileDevice()) {
                gameControls.classList.remove('hidden');
                gameControls.classList.add('flex');
            } else {
                gameControls.classList.add('hidden');
                gameControls.classList.remove('flex');
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = Math.min(window.innerHeight * 0.7, containerWidth * 1.5);
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;

            roadWidth = canvasWidth * 0.7;
            roadLeftEdge = (canvasWidth - roadWidth) / 2;

            player.x = Math.max(roadLeftEdge + 15, Math.min(player.x, roadLeftEdge + roadWidth - player.width - 15));
            player.y = canvasHeight - player.height - 20;
        }

        function createInitialRoadElements() {
            roadElements.push({ type: 'roadEdge', x: roadLeftEdge, y: 0, width: 10, height: canvasHeight });
            roadElements.push({ type: 'roadEdge', x: roadLeftEdge + roadWidth - 10, y: 0, width: 10, height: canvasHeight });

            const lineCount = Math.ceil(canvasHeight / 40);
            for (let i = 0; i < lineCount; i++) {
                roadElements.push({ type: 'centerLine', x: canvasWidth / 2 - 3, y: i * 60 - 20, width: 6, height: 30 });
            }
        }

        function updateRoadElements(deltaTime) {
            roadElements.forEach(element => element.y += roadSpeed * deltaTime * 60);
            roadElements = roadElements.filter(element => element.y < canvasHeight + 50);

            if (roadElements.filter(e => e.type === 'centerLine').length < 15) {
                roadElements.push({ type: 'centerLine', x: canvasWidth / 2 - 3, y: -20, width: 6, height: 30 });
            }
        }

        function spawnVehicles() {
            const spawnProbability = 0.02 * difficulty;
            if (Math.random() < spawnProbability) {
                const vehicleType = Math.random() < 0.7 ? 'enemy' : 'civilian';
                const minX = roadLeftEdge + 20;
                const maxX = roadLeftEdge + roadWidth - 50;
                const randomX = minX + Math.random() * (maxX - minX);
                
                vehicles.push({
                    type: vehicleType,
                    x: randomX,
                    y: -60,
                    width: 30,
                    height: 50,
                    speed: vehicleType === 'enemy' ? roadSpeed * 0.8 : roadSpeed * 0.6,
                    health: vehicleType === 'enemy' ? 2 : 1,
                    behavior: vehicleType === 'enemy' ? (Math.random() < 0.5 ? 'chase' : 'zigzag') : 'straight',
                    behaviorTimer: 0,
                    behaviorDirection: Math.random() < 0.5 ? -1 : 1
                });
            }
        }

        function updateVehicles(deltaTime) {
            vehicles.forEach(vehicle => {
                vehicle.y += roadSpeed * deltaTime * 60;
                
                if (vehicle.type === 'enemy') {
                    if (vehicle.behavior === 'chase') {
                        const targetX = player.x > vehicle.x ? 1 : -1;
                        vehicle.x += targetX * 1.5 * deltaTime * 60;
                    } else if (vehicle.behavior === 'zigzag') {
                        vehicle.behaviorTimer++;
                        if (vehicle.behaviorTimer > 30) {
                            vehicle.behaviorDirection *= -1;
                            vehicle.behaviorTimer = 0;
                        }
                        vehicle.x += vehicle.behaviorDirection * 2 * deltaTime * 60;
                    }
                }
                
                if (vehicle.x < roadLeftEdge + 15) {
                    vehicle.x = roadLeftEdge + 15;
                    if (vehicle.behavior === 'zigzag') vehicle.behaviorDirection *= -1;
                }
                
                if (vehicle.x + vehicle.width > roadLeftEdge + roadWidth - 15) {
                    vehicle.x = roadLeftEdge + roadWidth - vehicle.width - 15;
                    if (vehicle.behavior === 'zigzag') vehicle.behaviorDirection *= -1;
                }
            });
            
            vehicles = vehicles.filter(vehicle => vehicle.y < canvasHeight + 100);
        }

        function handlePlayerMovement(deltaTime) {
            let horizontalMovement = 0;
            let verticalMovement = 0;
            
            if (controls.left) horizontalMovement -= player.speed;
            if (controls.right) horizontalMovement += player.speed;
            if (controls.up) verticalMovement -= player.speed * 0.7;
            if (controls.down) verticalMovement += player.speed * 0.7;
            
            player.x += horizontalMovement * deltaTime * 60;
            player.y += verticalMovement * deltaTime * 60;
            
            player.x = Math.max(roadLeftEdge + 15, Math.min(player.x, roadLeftEdge + roadWidth - player.width - 15));
            player.y = Math.max(canvasHeight / 2, Math.min(player.y, canvasHeight - player.height - 10));
            
            if (controls.fire && player.cooldown <= 0) {
                fireBullet();
                player.cooldown = player.maxCooldown;
            }
            
            if (player.cooldown > 0) player.cooldown -= deltaTime * 60;
            if (player.isDamaged) {
                player.damageTimer -= deltaTime * 60;
                if (player.damageTimer <= 0) player.isDamaged = false;
            }
            
            if (player.isInvulnerable) {
                player.invulnerabilityTimer -= deltaTime * 60;
                if (player.invulnerabilityTimer <= 0) player.isInvulnerable = false;
            }
            
            if (weaponType !== "standard") {
                weaponTimer -= deltaTime * 60;
                if (weaponTimer <= 0) {
                    weaponType = "standard";
                    weaponStatus.textContent = "Weapon: Standard";
                    player.maxCooldown = 10;
                }
            }
        }

        function fireBullet() {
            if (weaponType === "standard") {
                bullets.push({ x: player.x + player.width / 2 - 2, y: player.y - 10, width: 4, height: 10, speed: 10, damage: 1, type: "standard" });
            } else if (weaponType === "double") {
                bullets.push({ x: player.x + 5, y: player.y, width: 4, height: 10, speed: 10, damage: 1, type: "double" });
                bullets.push({ x: player.x + player.width - 9, y: player.y, width: 4, height: 10, speed: 10, damage: 1, type: "double" });
            } else if (weaponType === "spread") {
                for (let i = -1; i <= 1; i++) {
                    bullets.push({ x: player.x + player.width / 2 - 2, y: player.y - 5, width: 4, height: 10, speed: 10, damage: 1, type: "spread", xVelocity: i * 2 });
                }
            }
        }

        function updateBullets(deltaTime) {
            bullets.forEach(bullet => {
                bullet.y -= bullet.speed * deltaTime * 60;
                if (bullet.type === "spread" && bullet.xVelocity) bullet.x += bullet.xVelocity * deltaTime * 60;
            });
            bullets = bullets.filter(bullet => bullet.y > -20);
        }

        function spawnPowerups() {
            if (Math.random() < 0.002 * difficulty) {
                const types = ["double", "spread", "life"];
                const randomType = types[Math.floor(Math.random() * types.length)];
                const minX = roadLeftEdge + 20;
                const maxX = roadLeftEdge + roadWidth - 40;
                const randomX = minX + Math.random() * (maxX - minX);
                
                vehicles.push({ type: 'powerup', powerupType: randomType, x: randomX, y: -40, width: 20, height: 20, speed: roadSpeed * 0.5 });
            }
        }

        function checkCollisions() {
            const bulletsToRemove = [];
            const vehiclesToRemove = [];

            bullets.forEach((bullet, bulletIndex) => {
                vehicles.forEach((vehicle, vehicleIndex) => {
                    if (vehicle.type !== 'powerup' && 
                        bullet.x < vehicle.x + vehicle.width &&
                        bullet.x + bullet.width > vehicle.x &&
                        bullet.y < vehicle.y + vehicle.height &&
                        bullet.y + bullet.height > vehicle.y) {
                        bulletsToRemove.push(bulletIndex);
                        vehicle.health -= bullet.damage;
                        createEffect('hit', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                        
                        if (vehicle.health <= 0) {
                            if (vehicle.type === 'enemy') {
                                score += 100 * difficulty;
                                scoreDisplay.textContent = score;
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                            } else if (vehicle.type === 'civilian') {
                                score = Math.max(0, score - 50);
                                scoreDisplay.textContent = score;
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                            }
                            vehiclesToRemove.push(vehicleIndex);
                        }
                    }
                });
            });

            bulletsToRemove.sort((a, b) => b - a).forEach(index => bullets.splice(index, 1));
            vehiclesToRemove.sort((a, b) => b - a).forEach(index => vehicles.splice(index, 1));

            if (!player.isInvulnerable) {
                vehicles.forEach((vehicle, vehicleIndex) => {
                    if (player.x < vehicle.x + vehicle.width &&
                        player.x + player.width > vehicle.x &&
                        player.y < vehicle.y + vehicle.height &&
                        player.y + player.height > vehicle.y) {
                        if (vehicle.type === 'powerup') {
                            handlePowerup(vehicle.powerupType);
                            vehicles.splice(vehicleIndex, 1);
                        } else {
                            handlePlayerCrash();
                            if (vehicle.type === 'enemy') {
                                vehicle.health = 0;
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                                vehicles.splice(vehicleIndex, 1);
                            }
                        }
                    }
                });
            }
            
            if (player.x < roadLeftEdge + 10 || player.x + player.width > roadLeftEdge + roadWidth - 10) {
                if (!player.isInvulnerable) handlePlayerCrash();
            }
        }

        function handlePowerup(type) {
            if (type === "double") {
                weaponType = "double";
                weaponTimer = 500;
                player.maxCooldown = 8;
                weaponStatus.textContent = "Weapon: Double";
            } else if (type === "spread") {
                weaponType = "spread";
                weaponTimer = 500;
                player.maxCooldown = 15;
                weaponStatus.textContent = "Weapon: Spread";
            } else if (type === "life") {
                if (lives < 5) {
                    lives++;
                    livesDisplay.textContent = lives;
                } else {
                    score += 200;
                    scoreDisplay.textContent = score;
                }
            }
            createEffect('powerup', player.x + player.width / 2, player.y + player.height / 2);
        }

        function handlePlayerCrash() {
            lives--;
            livesDisplay.textContent = lives;
            player.isDamaged = true;
            player.damageTimer = 20;
            player.isInvulnerable = true;
            player.invulnerabilityTimer = 60;
            createEffect('crash', player.x + player.width / 2, player.y + player.height / 2);
            if (lives <= 0) endGame();
        }

        function createEffect(type, x, y) {
            if (type === 'explosion') {
                for (let i = 0; i < 15; i++) {
                    effects.push({
                        type: 'particle',
                        x, y,
                        size: 2 + Math.random() * 6,
                        speed: 1 + Math.random() * 3,
                        angle: Math.random() * Math.PI * 2,
                        life: 20 + Math.random() * 10,
                        color: Math.random() < 0.7 ? '#FF6600' : '#FFCC00'
                    });
                }
            } else if (type === 'hit') {
                for (let i = 0; i < 5; i++) {
                    effects.push({
                        type: 'particle',
                        x, y,
                        size: 1 + Math.random() * 3,
                        speed: 0.5 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 10 + Math.random() * 5,
                        color: '#FFFFFF'
                    });
                }
            } else if (type === 'crash') {
                for (let i = 0; i < 10; i++) {
                    effects.push({
                        type: 'smoke',
                        x, y,
                        size: 3 + Math.random() * 8,
                        speed: 0.3 + Math.random() * 1,
                        angle: Math.random() * Math.PI * 2,
                        life: 30 + Math.random() * 20,
                        maxLife: 30 + Math.random() * 20,
                        color: 'var(--smoke-color)'
                    });
                }
            } else if (type === 'powerup') {
                for (let i = 0; i < 8; i++) {
                    effects.push({
                        type: 'particle',
                        x, y,
                        size: 2 + Math.random() * 4,
                        speed: 0.5 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 15 + Math.random() * 10,
                        color: '#00FFFF'
                    });
                }
            }
        }

        function updateEffects(deltaTime) {
            effects.forEach(effect => {
                if (effect.type === 'particle' || effect.type === 'smoke') {
                    effect.x += Math.cos(effect.angle) * effect.speed * deltaTime * 60;
                    effect.y += Math.sin(effect.angle) * effect.speed * deltaTime * 60;
                    effect.life -= deltaTime * 60;
                    if (effect.type === 'smoke') effect.size = effect.size * (effect.life / effect.maxLife);
                }
            });
            effects = effects.filter(effect => effect.life > 0);
        }

        function increaseDifficulty() {
            if (score > 1000 * difficulty) {
                difficulty += 0.2;
                roadSpeed = Math.min(3 + difficulty, 8);
            }
        }

        function renderGame() {
            ctx.fillStyle = 'var(--grass-color)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = 'var(--road-color)';
            ctx.fillRect(roadLeftEdge, 0, roadWidth, canvasHeight);
            
            roadElements.forEach(element => {
                ctx.fillStyle = element.type === 'roadEdge' || element.type === 'centerLine' ? 'var(--road-line-color)' : 'var(--road-color)';
                ctx.fillRect(element.x, element.y, element.width, element.height);
            });
            
            ctx.fillStyle = 'var(--bullet-color)';
            bullets.forEach(bullet => ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height));
            
            vehicles.forEach(vehicle => {
                if (vehicle.type === 'enemy') {
                    ctx.fillStyle = 'var(--enemy-color)';
                    ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(vehicle.x + 5, vehicle.y + 5, 5, 10);
                    ctx.fillRect(vehicle.x + vehicle.width - 10, vehicle.y + 5, 5, 10);
                    ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height - 15, vehicle.width - 10, 5);
                } else if (vehicle.type === 'civilian') {
                    ctx.fillStyle = 'var(--civilian-color)';
                    ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(vehicle.x + 5, vehicle.y + 10, 5, 8);
                    ctx.fillRect(vehicle.x + vehicle.width - 10, vehicle.y + 10, 5, 8);
                    ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height - 15, vehicle.width - 10, 5);
                } else if (vehicle.type === 'powerup') {
                    ctx.fillStyle = vehicle.powerupType === 'double' ? '#FF00FF' : vehicle.powerupType === 'spread' ? '#00FFFF' : '#00FF00';
                    ctx.beginPath();
                    ctx.arc(vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2, vehicle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFFFFF';
                    if (vehicle.powerupType === 'double') {
                        ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height / 2 - 1, 4, 2);
                        ctx.fillRect(vehicle.x + vehicle.width - 9, vehicle.y + vehicle.height / 2 - 1, 4, 2);
                    } else if (vehicle.powerupType === 'spread') {
                        ctx.beginPath();
                        ctx.moveTo(vehicle.x + vehicle.width / 2, vehicle.y + 5);
                        ctx.lineTo(vehicle.x + 5, vehicle.y + vehicle.height - 5);
                        ctx.lineTo(vehicle.x + vehicle.width - 5, vehicle.y + vehicle.height - 5);
                        ctx.fill();
                    } else if (vehicle.powerupType === 'life') {
                        ctx.beginPath();
                        ctx.arc(vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2, vehicle.width / 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            if (!player.isDamaged || (player.isDamaged && Math.floor(player.damageTimer / 2) % 2 === 0)) {
                ctx.fillStyle = player.isInvulnerable && Math.floor(player.invulnerabilityTimer / 5) % 2 === 0 ? '#AAAAFF' : 'var(--player-color)';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.fillStyle = '#000000';
                ctx.fillRect(player.x + 5, player.y + 10, 5, 8);
                ctx.fillRect(player.x + player.width - 10, player.y + 10, 5, 8);
                ctx.fillRect(player.x + 5, player.y + player.height - 15, player.width - 10, 5);
            }
            
            effects.forEach(effect => {
                ctx.fillStyle = effect.color;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function gameLoop(timestamp) {
            const deltaTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1);
            lastTimestamp = timestamp;
            
            if (!gameRunning) return;
            
            roadSpeed = Math.min(3 + difficulty, 8);
            player.speed = 5;
            
            updateRoadElements(deltaTime);
            spawnVehicles();
            spawnPowerups();
            updateVehicles(deltaTime);
            handlePlayerMovement(deltaTime);
            updateBullets(deltaTime);
            checkCollisions();
            updateEffects(deltaTime);
            increaseDifficulty();
            
            renderGame();
            
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
            finalScore.textContent = `Final Score: ${score}`;
            gameControls.classList.add('hidden');
        }

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        }

        // Event listeners
        startButton.addEventListener('click', () => {
            startScreen.classList.add('hidden');
            initGame();
        });

        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.remove('flex');
            gameOverScreen.classList.add('hidden');
            initGame();
        });

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') controls.left = true;
            if (e.key === 'ArrowRight') controls.right = true;
            if (e.key === 'ArrowUp') controls.up = true;
            if (e.key === 'ArrowDown') controls.down = true;
            if (e.key === ' ') controls.fire = true;
        });

        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') controls.left = false;
            if (e.key === 'ArrowRight') controls.right = false;
            if (e.key === 'ArrowUp') controls.up = false;
            if (e.key === 'ArrowDown') controls.down = false;
            if (e.key === ' ') controls.fire = false;
        });

        leftBtn.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStates.set(touch.identifier, 'left');
            controls.left = true;
        }, { passive: false });

        leftBtn.addEventListener('touchend', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchStates.delete(touch.identifier);
            controls.left = touchStates.has('left');
        });

        rightBtn.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStates.set(touch.identifier, 'right');
            controls.right = true;
        }, { passive: false });

        rightBtn.addEventListener('touchend', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchStates.delete(touch.identifier);
            controls.right = touchStates.has('right');
        });

        fireBtn.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStates.set(touch.identifier, 'fire');
            controls.fire = true;
        }, { passive: false });

        fireBtn.addEventListener('touchend', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            touchStates.delete(touch.identifier);
            controls.fire = touchStates.has('fire');
        });

        leftBtn.addEventListener('mousedown', () => controls.left = true);
        leftBtn.addEventListener('mouseup', () => controls.left = false);
        leftBtn.addEventListener('mouseleave', () => controls.left = false);

        rightBtn.addEventListener('mousedown', () => controls.right = true);
        rightBtn.addEventListener('mouseup', () => controls.right = false);
        rightBtn.addEventListener('mouseleave', () => controls.right = false);

        fireBtn.addEventListener('mousedown', () => controls.fire = true);
        fireBtn.addEventListener('mouseup', () => controls.fire = false);
        fireBtn.addEventListener('mouseleave', () => controls.fire = false);

        window.addEventListener('resize', () => {
            if (gameRunning) {
                const oldRoadLeftEdge = roadLeftEdge;
                const oldRoadWidth = roadWidth;
                
                resizeCanvas();
                
                const roadScaleX = roadWidth / oldRoadWidth;
                const roadOffsetX = roadLeftEdge - oldRoadLeftEdge;
                
                player.x = (player.x - oldRoadLeftEdge) * roadScaleX + roadLeftEdge;
                player.x = Math.max(roadLeftEdge + 15, Math.min(player.x, roadLeftEdge + roadWidth - player.width - 15));
                
                roadElements.forEach(element => {
                    if (element.type === 'roadEdge') {
                        element.x = element.x < canvasWidth / 2 ? roadLeftEdge : roadLeftEdge + roadWidth - element.width;
                    } else if (element.type === 'centerLine') {
                        element.x = canvasWidth / 2 - element.width / 2;
                    }
                });
            }
        });
    </script>
</body>
</html>
