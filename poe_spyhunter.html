<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spy Hunter Clone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --road-color: #333333;
            --road-line-color: #FFFFFF;
            --grass-color: #228B22;
            --water-color: #1E90FF;
            --player-color: #5D5CDE;
            --enemy-color: #FF0000;
            --civilian-color: #FFFF00;
            --bullet-color: #FFFFFF;
            --oil-color: #000000;
            --smoke-color: #CCCCCC;
            --ui-bg: rgba(255, 255, 255, 0.8);
            --text-color: #000000;
        }

        .dark {
            --road-color: #1a1a1a;
            --road-line-color: #DDDDDD;
            --grass-color: #0e5c0e;
            --water-color: #0066cc;
            --player-color: #5D5CDE;
            --enemy-color: #FF3333;
            --civilian-color: #CCCC00;
            --bullet-color: #FFFFFF;
            --oil-color: #333333;
            --smoke-color: #999999;
            --ui-bg: rgba(30, 30, 30, 0.8);
            --text-color: #FFFFFF;
        }

        body {
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #gameControls button {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 min-h-screen flex flex-col items-center justify-start">
    <div class="w-full max-w-lg px-2 py-4">
        <h1 class="text-2xl font-bold text-center text-gray-900 dark:text-white mb-2">Spy Hunter</h1>
        
        <div id="gameContainer" class="relative w-full">
            <canvas id="gameCanvas" class="border-2 border-gray-300 dark:border-gray-700 w-full rounded-md shadow-md"></canvas>
            
            <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-white dark:bg-gray-900 bg-opacity-90 dark:bg-opacity-90 rounded-md">
                <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-4">SPY HUNTER</h2>
                <p class="text-gray-700 dark:text-gray-300 mb-6 text-center px-4">Drive your spy car, shoot enemies, and avoid civilians!</p>
                <button id="startButton" class="bg-primary hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded focus:outline-none">
                    START GAME
                </button>
                <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center px-4">
                    <p class="mb-2"><b>Controls:</b></p>
                    <p class="mb-1">Desktop: Arrow keys to move, Space to shoot</p>
                    <p>Mobile: On-screen controls appear during gameplay</p>
                </div>
            </div>
            
            <div id="gameOverScreen" class="absolute inset-0 flex-col items-center justify-center bg-white dark:bg-gray-900 bg-opacity-90 dark:bg-opacity-90 rounded-md hidden">
                <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-2">GAME OVER</h2>
                <p id="finalScore" class="text-lg text-gray-800 dark:text-gray-200 mb-6"></p>
                <button id="restartButton" class="bg-primary hover:bg-opacity-90 text-white font-bold py-2 px-4 rounded focus:outline-none">
                    PLAY AGAIN
                </button>
            </div>
            
            <div id="gameControls" class="absolute bottom-4 left-0 right-0 flex justify-between px-6 hidden">
                <div class="flex">
                    <button id="leftBtn" class="bg-gray-800 bg-opacity-60 text-white w-12 h-12 rounded-l-full flex items-center justify-center focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>
                    <button id="rightBtn" class="bg-gray-800 bg-opacity-60 text-white w-12 h-12 rounded-r-full flex items-center justify-center focus:outline-none">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                </div>
                <button id="fireBtn" class="bg-red-600 bg-opacity-70 text-white w-16 h-16 rounded-full flex items-center justify-center focus:outline-none">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="flex justify-between mt-2 px-2">
            <div>
                <p class="text-sm text-gray-700 dark:text-gray-300">Score: <span id="scoreDisplay">0</span></p>
                <p class="text-sm text-gray-700 dark:text-gray-300">Lives: <span id="livesDisplay">3</span></p>
            </div>
            <div id="weaponStatus" class="text-sm text-gray-700 dark:text-gray-300">
                Weapon: Standard
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const gameControls = document.getElementById('gameControls');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const finalScore = document.getElementById('finalScore');
        const weaponStatus = document.getElementById('weaponStatus');

        // Mobile controls
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const fireBtn = document.getElementById('fireBtn');

        // Game state
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let roadSpeed = 3;
        let roadPosition = 0;
        let roadWidth = 0;
        let roadLeftEdge = 0;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let lastTimestamp = 0;
        let difficulty = 1;
        let weaponType = "standard";
        let weaponTimer = 0;

        // Road elements
        let roadElements = [];

        // Player
        let player = {
            width: 30,
            height: 50,
            x: 0,
            y: 0,
            speed: 5,
            isShooting: false,
            cooldown: 0,
            maxCooldown: 10,
            isDamaged: false,
            damageTimer: 0,
            isInvulnerable: false,
            invulnerabilityTimer: 0
        };

        // Bullets
        let bullets = [];

        // Enemies and civilians
        let vehicles = [];

        // Effects
        let effects = [];

        // Controls state
        const controls = {
            left: false,
            right: false,
            up: false,
            down: false,
            fire: false
        };

        // Initialize game
        function initGame() {
            // Set canvas dimensions based on container
            resizeCanvas();

            // Set player initial position
            player.x = canvasWidth / 2 - player.width / 2;
            player.y = canvasHeight - player.height - 20;

            // Reset game state
            score = 0;
            lives = 3;
            roadSpeed = 3;
            roadPosition = 0;
            difficulty = 1;
            weaponType = "standard";
            weaponTimer = 0;
            roadElements = [];
            bullets = [];
            vehicles = [];
            effects = [];
            
            // Update UI
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            weaponStatus.textContent = "Weapon: Standard";

            // Initialize road
            roadWidth = canvasWidth * 0.7;
            roadLeftEdge = (canvasWidth - roadWidth) / 2;

            // Create initial road elements (grass, road edges)
            createInitialRoadElements();

            // Start game
            gameRunning = true;
            lastTimestamp = performance.now();
            requestAnimationFrame(gameLoop);

            // Show touch controls on mobile
            if (isMobileDevice()) {
                gameControls.classList.remove('hidden');
                gameControls.classList.add('flex');
            } else {
                gameControls.classList.add('hidden');
                gameControls.classList.remove('flex');
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            canvas.width = containerWidth;
            canvas.height = Math.min(window.innerHeight * 0.7, containerWidth * 1.5);
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
        }

        function createInitialRoadElements() {
            // Create road edges
            roadElements.push({
                type: 'roadEdge',
                x: roadLeftEdge,
                y: 0,
                width: 10,
                height: canvasHeight
            });
            
            roadElements.push({
                type: 'roadEdge',
                x: roadLeftEdge + roadWidth - 10,
                y: 0,
                width: 10,
                height: canvasHeight
            });

            // Create center line sections
            const lineCount = Math.ceil(canvasHeight / 40);
            for (let i = 0; i < lineCount; i++) {
                roadElements.push({
                    type: 'centerLine',
                    x: canvasWidth / 2 - 3,
                    y: i * 60 - 20,
                    width: 6,
                    height: 30
                });
            }
        }

        function updateRoadElements() {
            // Move existing elements down
            roadElements.forEach(element => {
                element.y += roadSpeed;
            });

            // Remove elements that are off-screen
            roadElements = roadElements.filter(element => 
                element.y < canvasHeight + 50);

            // Add new center lines as needed
            if (roadElements.filter(e => e.type === 'centerLine').length < 15) {
                roadElements.push({
                    type: 'centerLine',
                    x: canvasWidth / 2 - 3,
                    y: -20,
                    width: 6,
                    height: 30
                });
            }
        }

        function spawnVehicles() {
            const spawnProbability = 0.02 * difficulty;
            
            if (Math.random() < spawnProbability) {
                // Determine vehicle type
                const vehicleType = Math.random() < 0.7 ? 'enemy' : 'civilian';
                
                // Calculate random x position on road
                const minX = roadLeftEdge + 20;
                const maxX = roadLeftEdge + roadWidth - 20 - 30;
                const randomX = minX + Math.random() * (maxX - minX);
                
                // Create vehicle
                const vehicle = {
                    type: vehicleType,
                    x: randomX,
                    y: -60,
                    width: 30,
                    height: 50,
                    speed: vehicleType === 'enemy' ? roadSpeed * 0.8 : roadSpeed * 0.6,
                    health: vehicleType === 'enemy' ? 2 : 1,
                    behavior: vehicleType === 'enemy' ? (Math.random() < 0.5 ? 'chase' : 'zigzag') : 'straight',
                    behaviorTimer: 0,
                    behaviorDirection: Math.random() < 0.5 ? -1 : 1
                };
                
                vehicles.push(vehicle);
            }
        }

        function updateVehicles() {
            vehicles.forEach(vehicle => {
                // Move down with road
                vehicle.y += roadSpeed;
                
                // Apply behavior
                if (vehicle.type === 'enemy') {
                    if (vehicle.behavior === 'chase') {
                        // Move towards player
                        const targetX = player.x > vehicle.x ? 1 : -1;
                        vehicle.x += targetX * 1.5;
                    } else if (vehicle.behavior === 'zigzag') {
                        // Change direction periodically
                        vehicle.behaviorTimer++;
                        if (vehicle.behaviorTimer > 30) {
                            vehicle.behaviorDirection *= -1;
                            vehicle.behaviorTimer = 0;
                        }
                        vehicle.x += vehicle.behaviorDirection * 2;
                    }
                }
                
                // Keep vehicles on road
                if (vehicle.x < roadLeftEdge + 15) {
                    vehicle.x = roadLeftEdge + 15;
                    if (vehicle.behavior === 'zigzag') vehicle.behaviorDirection *= -1;
                }
                
                if (vehicle.x + vehicle.width > roadLeftEdge + roadWidth - 15) {
                    vehicle.x = roadLeftEdge + roadWidth - vehicle.width - 15;
                    if (vehicle.behavior === 'zigzag') vehicle.behaviorDirection *= -1;
                }
            });
            
            // Remove vehicles that are off-screen
            vehicles = vehicles.filter(vehicle => vehicle.y < canvasHeight + 100);
        }

        function handlePlayerMovement() {
            let horizontalMovement = 0;
            let verticalMovement = 0;
            
            // Apply keyboard or touch controls
            if (controls.left) horizontalMovement -= player.speed;
            if (controls.right) horizontalMovement += player.speed;
            if (controls.up) verticalMovement -= player.speed * 0.7;
            if (controls.down) verticalMovement += player.speed * 0.7;
            
            // Update player position
            player.x += horizontalMovement;
            player.y += verticalMovement;
            
            // Keep player on road
            if (player.x < roadLeftEdge + 15) {
                player.x = roadLeftEdge + 15;
            }
            
            if (player.x + player.width > roadLeftEdge + roadWidth - 15) {
                player.x = roadLeftEdge + roadWidth - player.width - 15;
            }
            
            // Limit vertical movement
            if (player.y < canvasHeight / 2) {
                player.y = canvasHeight / 2;
            }
            
            if (player.y + player.height > canvasHeight - 10) {
                player.y = canvasHeight - player.height - 10;
            }
            
            // Handle shooting
            if (controls.fire && player.cooldown <= 0) {
                fireBullet();
                player.cooldown = player.maxCooldown;
            }
            
            // Update cooldown
            if (player.cooldown > 0) {
                player.cooldown--;
            }
            
            // Update damage animation
            if (player.isDamaged) {
                player.damageTimer--;
                if (player.damageTimer <= 0) {
                    player.isDamaged = false;
                }
            }
            
            // Update invulnerability
            if (player.isInvulnerable) {
                player.invulnerabilityTimer--;
                if (player.invulnerabilityTimer <= 0) {
                    player.isInvulnerable = false;
                }
            }
            
            // Update weapon timer
            if (weaponType !== "standard") {
                weaponTimer--;
                if (weaponTimer <= 0) {
                    weaponType = "standard";
                    weaponStatus.textContent = "Weapon: Standard";
                    player.maxCooldown = 10;
                }
            }
        }

        function fireBullet() {
            if (weaponType === "standard") {
                // Standard single bullet
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y - 10,
                    width: 4,
                    height: 10,
                    speed: 10,
                    damage: 1,
                    type: "standard"
                });
            } else if (weaponType === "double") {
                // Double bullets
                bullets.push({
                    x: player.x + 5,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 10,
                    damage: 1,
                    type: "double"
                });
                bullets.push({
                    x: player.x + player.width - 9,
                    y: player.y,
                    width: 4,
                    height: 10,
                    speed: 10,
                    damage: 1,
                    type: "double"
                });
            } else if (weaponType === "spread") {
                // Spread bullets
                for (let i = -1; i <= 1; i++) {
                    bullets.push({
                        x: player.x + player.width / 2 - 2,
                        y: player.y - 5,
                        width: 4,
                        height: 10,
                        speed: 10,
                        damage: 1,
                        type: "spread",
                        xVelocity: i * 2
                    });
                }
            }
        }

        function updateBullets() {
            bullets.forEach(bullet => {
                bullet.y -= bullet.speed;
                
                // For spread bullets, also update x position
                if (bullet.type === "spread" && bullet.xVelocity) {
                    bullet.x += bullet.xVelocity;
                }
            });
            
            // Remove bullets that are off-screen
            bullets = bullets.filter(bullet => bullet.y > -20);
        }

        function spawnPowerups() {
            // Random chance to spawn a powerup
            if (Math.random() < 0.002 * difficulty) {
                const types = ["double", "spread", "life"];
                const randomType = types[Math.floor(Math.random() * types.length)];
                
                // Calculate random x position on road
                const minX = roadLeftEdge + 20;
                const maxX = roadLeftEdge + roadWidth - 20 - 20;
                const randomX = minX + Math.random() * (maxX - minX);
                
                // Create powerup
                vehicles.push({
                    type: 'powerup',
                    powerupType: randomType,
                    x: randomX,
                    y: -40,
                    width: 20,
                    height: 20,
                    speed: roadSpeed * 0.5
                });
            }
        }

        function checkCollisions() {
            // Bullet-vehicle collisions
            bullets.forEach((bullet, bulletIndex) => {
                vehicles.forEach((vehicle, vehicleIndex) => {
                    if (vehicle.type !== 'powerup' && 
                        bullet.x < vehicle.x + vehicle.width &&
                        bullet.x + bullet.width > vehicle.x &&
                        bullet.y < vehicle.y + vehicle.height &&
                        bullet.y + bullet.height > vehicle.y) {
                        
                        // Bullet hit vehicle
                        bullets.splice(bulletIndex, 1);
                        
                        // Apply damage
                        vehicle.health -= bullet.damage;
                        
                        // Create hit effect
                        createEffect('hit', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                        
                        // Check if vehicle is destroyed
                        if (vehicle.health <= 0) {
                            if (vehicle.type === 'enemy') {
                                // Add score for destroying enemy
                                score += 100 * difficulty;
                                scoreDisplay.textContent = score;
                                
                                // Create explosion effect
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                            } else if (vehicle.type === 'civilian') {
                                // Penalty for destroying civilian
                                score = Math.max(0, score - 50);
                                scoreDisplay.textContent = score;
                                
                                // Create explosion effect
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                            }
                            
                            // Remove vehicle
                            vehicles.splice(vehicleIndex, 1);
                        }
                    }
                });
            });
            
            // Player-vehicle collisions
            if (!player.isInvulnerable) {
                vehicles.forEach((vehicle, vehicleIndex) => {
                    if (player.x < vehicle.x + vehicle.width &&
                        player.x + player.width > vehicle.x &&
                        player.y < vehicle.y + vehicle.height &&
                        player.y + player.height > vehicle.y) {
                        
                        if (vehicle.type === 'powerup') {
                            // Collect powerup
                            handlePowerup(vehicle.powerupType);
                            vehicles.splice(vehicleIndex, 1);
                        } else {
                            // Player crashed
                            handlePlayerCrash();
                            
                            if (vehicle.type === 'enemy') {
                                // Destroy enemy on collision
                                vehicle.health = 0;
                                createEffect('explosion', vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2);
                                vehicles.splice(vehicleIndex, 1);
                            }
                        }
                    }
                });
            }
            
            // Player-road edge collisions
            if (player.x < roadLeftEdge + 10 || player.x + player.width > roadLeftEdge + roadWidth - 10) {
                if (!player.isInvulnerable) {
                    handlePlayerCrash();
                }
            }
        }

        function handlePowerup(type) {
            if (type === "double") {
                weaponType = "double";
                weaponTimer = 500;
                player.maxCooldown = 8;
                weaponStatus.textContent = "Weapon: Double";
            } else if (type === "spread") {
                weaponType = "spread";
                weaponTimer = 500;
                player.maxCooldown = 15;
                weaponStatus.textContent = "Weapon: Spread";
            } else if (type === "life") {
                if (lives < 5) {
                    lives++;
                    livesDisplay.textContent = lives;
                } else {
                    // Add score instead if max lives
                    score += 200;
                    scoreDisplay.textContent = score;
                }
            }
            
            // Create effect
            createEffect('powerup', player.x + player.width / 2, player.y + player.height / 2);
        }

        function handlePlayerCrash() {
            lives--;
            livesDisplay.textContent = lives;
            
            player.isDamaged = true;
            player.damageTimer = 20;
            
            player.isInvulnerable = true;
            player.invulnerabilityTimer = 60;
            
            // Create crash effect
            createEffect('crash', player.x + player.width / 2, player.y + player.height / 2);
            
            if (lives <= 0) {
                endGame();
            }
        }

        function createEffect(type, x, y) {
            if (type === 'explosion') {
                // Create multiple particles for explosion
                for (let i = 0; i < 15; i++) {
                    effects.push({
                        type: 'particle',
                        x: x,
                        y: y,
                        size: 2 + Math.random() * 6,
                        speed: 1 + Math.random() * 3,
                        angle: Math.random() * Math.PI * 2,
                        life: 20 + Math.random() * 10,
                        color: Math.random() < 0.7 ? '#FF6600' : '#FFCC00'
                    });
                }
            } else if (type === 'hit') {
                // Create hit effect
                for (let i = 0; i < 5; i++) {
                    effects.push({
                        type: 'particle',
                        x: x,
                        y: y,
                        size: 1 + Math.random() * 3,
                        speed: 0.5 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 10 + Math.random() * 5,
                        color: '#FFFFFF'
                    });
                }
            } else if (type === 'crash') {
                // Create smoke effect
                for (let i = 0; i < 10; i++) {
                    effects.push({
                        type: 'smoke',
                        x: x,
                        y: y,
                        size: 3 + Math.random() * 8,
                        speed: 0.3 + Math.random() * 1,
                        angle: Math.random() * Math.PI * 2,
                        life: 30 + Math.random() * 20,
                        maxLife: 30 + Math.random() * 20,
                        color: 'var(--smoke-color)'
                    });
                }
            } else if (type === 'powerup') {
                // Create powerup collection effect
                for (let i = 0; i < 8; i++) {
                    effects.push({
                        type: 'particle',
                        x: x,
                        y: y,
                        size: 2 + Math.random() * 4,
                        speed: 0.5 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2,
                        life: 15 + Math.random() * 10,
                        color: '#00FFFF'
                    });
                }
            }
        }

        function updateEffects() {
            effects.forEach(effect => {
                if (effect.type === 'particle' || effect.type === 'smoke') {
                    // Move particle
                    effect.x += Math.cos(effect.angle) * effect.speed;
                    effect.y += Math.sin(effect.angle) * effect.speed;
                    
                    // Reduce life
                    effect.life--;
                    
                    // For smoke, shrink as life decreases
                    if (effect.type === 'smoke') {
                        effect.size = effect.size * (effect.life / effect.maxLife);
                    }
                }
            });
            
            // Remove dead effects
            effects = effects.filter(effect => effect.life > 0);
        }

        function increaseDifficulty() {
            if (score > 1000 * difficulty) {
                difficulty += 0.2;
                roadSpeed = Math.min(3 + difficulty, 8);
            }
        }

        function renderGame() {
            // Clear canvas
            ctx.fillStyle = 'var(--grass-color)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // Draw road
            ctx.fillStyle = 'var(--road-color)';
            ctx.fillRect(roadLeftEdge, 0, roadWidth, canvasHeight);
            
            // Draw road elements
            roadElements.forEach(element => {
                if (element.type === 'roadEdge') {
                    ctx.fillStyle = 'var(--road-line-color)';
                    ctx.fillRect(element.x, element.y, element.width, element.height);
                } else if (element.type === 'centerLine') {
                    ctx.fillStyle = 'var(--road-line-color)';
                    ctx.fillRect(element.x, element.y, element.width, element.height);
                }
            });
            
            // Draw bullets
            ctx.fillStyle = 'var(--bullet-color)';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            
            // Draw vehicles
            vehicles.forEach(vehicle => {
                if (vehicle.type === 'enemy') {
                    ctx.fillStyle = 'var(--enemy-color)';
                    ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
                    
                    // Draw enemy details
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(vehicle.x + 5, vehicle.y + 5, 5, 10);
                    ctx.fillRect(vehicle.x + vehicle.width - 10, vehicle.y + 5, 5, 10);
                    ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height - 15, vehicle.width - 10, 5);
                } else if (vehicle.type === 'civilian') {
                    ctx.fillStyle = 'var(--civilian-color)';
                    ctx.fillRect(vehicle.x, vehicle.y, vehicle.width, vehicle.height);
                    
                    // Draw civilian details
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(vehicle.x + 5, vehicle.y + 10, 5, 8);
                    ctx.fillRect(vehicle.x + vehicle.width - 10, vehicle.y + 10, 5, 8);
                    ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height - 15, vehicle.width - 10, 5);
                } else if (vehicle.type === 'powerup') {
                    // Draw powerup
                    if (vehicle.powerupType === 'double') {
                        ctx.fillStyle = '#FF00FF';
                    } else if (vehicle.powerupType === 'spread') {
                        ctx.fillStyle = '#00FFFF';
                    } else if (vehicle.powerupType === 'life') {
                        ctx.fillStyle = '#00FF00';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2, 
                              vehicle.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw icon
                    ctx.fillStyle = '#FFFFFF';
                    if (vehicle.powerupType === 'double') {
                        ctx.fillRect(vehicle.x + 5, vehicle.y + vehicle.height / 2 - 1, 4, 2);
                        ctx.fillRect(vehicle.x + vehicle.width - 9, vehicle.y + vehicle.height / 2 - 1, 4, 2);
                    } else if (vehicle.powerupType === 'spread') {
                        ctx.beginPath();
                        ctx.moveTo(vehicle.x + vehicle.width / 2, vehicle.y + 5);
                        ctx.lineTo(vehicle.x + 5, vehicle.y + vehicle.height - 5);
                        ctx.lineTo(vehicle.x + vehicle.width - 5, vehicle.y + vehicle.height - 5);
                        ctx.fill();
                    } else if (vehicle.powerupType === 'life') {
                        ctx.beginPath();
                        ctx.arc(vehicle.x + vehicle.width / 2, vehicle.y + vehicle.height / 2, 
                                  vehicle.width / 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
            
            // Draw player
            if (!player.isDamaged || (player.isDamaged && Math.floor(player.damageTimer / 2) % 2 === 0)) {
                if (player.isInvulnerable && Math.floor(player.invulnerabilityTimer / 5) % 2 === 0) {
                    ctx.fillStyle = '#AAAAFF';
                } else {
                    ctx.fillStyle = 'var(--player-color)';
                }
                ctx.fillRect(player.x, player.y, player.width, player.height);
                
                // Draw player details
                ctx.fillStyle = '#000000';
                ctx.fillRect(player.x + 5, player.y + 10, 5, 8);
                ctx.fillRect(player.x + player.width - 10, player.y + 10, 5, 8);
                ctx.fillRect(player.x + 5, player.y + vehicle.height - 15, player.width - 10, 5);
            }
            
            // Draw effects
            effects.forEach(effect => {
                if (effect.type === 'particle') {
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (effect.type === 'smoke') {
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function gameLoop(timestamp) {
            // Calculate delta time
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            
            if (!gameRunning) return;
            
            // Update game state
            updateRoadElements();
            spawnVehicles();
            spawnPowerups();
            updateVehicles();
            handlePlayerMovement();
            updateBullets();
            checkCollisions();
            updateEffects();
            increaseDifficulty();
            
            // Render game
            renderGame();
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
            finalScore.textContent = `Final Score: ${score}`;
            gameControls.classList.add('hidden');
        }

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        }

        // Event listeners
        startButton.addEventListener('click', function() {
            startScreen.classList.add('hidden');
            initGame();
        });

        restartButton.addEventListener('click', function() {
            gameOverScreen.classList.remove('flex');
            gameOverScreen.classList.add('hidden');
            initGame();
        });

        // Keyboard controls
        window.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') controls.left = true;
            if (e.key === 'ArrowRight') controls.right = true;
            if (e.key === 'ArrowUp') controls.up = true;
            if (e.key === 'ArrowDown') controls.down = true;
            if (e.key === ' ') controls.fire = true;
        });

        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft') controls.left = false;
            if (e.key === 'ArrowRight') controls.right = false;
            if (e.key === 'ArrowUp') controls.up = false;
            if (e.key === 'ArrowDown') controls.down = false;
            if (e.key === ' ') controls.fire = false;
        });

        // Touch controls
        leftBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            controls.left = true;
        }, { passive: false });

        leftBtn.addEventListener('touchend', function() {
            controls.left = false;
        });

        rightBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            controls.right = true;
        }, { passive: false });

        rightBtn.addEventListener('touchend', function() {
            controls.right = false;
        });

        fireBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            controls.fire = true;
        }, { passive: false });

        fireBtn.addEventListener('touchend', function() {
            controls.fire = false;
        });

        // Mouse controls for buttons
        leftBtn.addEventListener('mousedown', function() {
            controls.left = true;
        });

        leftBtn.addEventListener('mouseup', function() {
            controls.left = false;
        });

        leftBtn.addEventListener('mouseleave', function() {
            controls.left = false;
        });

        rightBtn.addEventListener('mousedown', function() {
            controls.right = true;
        });

        rightBtn.addEventListener('mouseup', function() {
            controls.right = false;
        });

        rightBtn.addEventListener('mouseleave', function() {
            controls.right = false;
        });

        fireBtn.addEventListener('mousedown', function() {
            controls.fire = true;
        });

        fireBtn.addEventListener('mouseup', function() {
            controls.fire = false;
        });

        fireBtn.addEventListener('mouseleave', function() {
            controls.fire = false;
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (gameRunning) {
                const oldRoadLeftEdge = roadLeftEdge;
                const oldRoadWidth = roadWidth;
                
                resizeCanvas();
                
                // Adjust road dimensions
                roadWidth = canvasWidth * 0.7;
                roadLeftEdge = (canvasWidth - roadWidth) / 2;
                
                // Adjust player position proportionally
                const roadScaleX = roadWidth / oldRoadWidth;
                const roadOffsetX = roadLeftEdge - oldRoadLeftEdge;
                
                player.x = (player.x - oldRoadLeftEdge) * roadScaleX + roadLeftEdge;
                
                // Keep player on road
                if (player.x < roadLeftEdge + 15) {
                    player.x = roadLeftEdge + 15;
                }
                
                if (player.x + player.width > roadLeftEdge + roadWidth - 15) {
                    player.x = roadLeftEdge + roadWidth - player.width - 15;
                }
                
                // Update road elements positions
                roadElements.forEach(element => {
                    if (element.type === 'roadEdge') {
                        if (element.x < canvasWidth / 2) {
                            element.x = roadLeftEdge;
                        } else {
                            element.x = roadLeftEdge + roadWidth - element.width;
                        }
                    } else if (element.type === 'centerLine') {
                        element.x = canvasWidth / 2 - element.width / 2;
                    }
                });
            }
        });
    </script>
</body>
</html>
