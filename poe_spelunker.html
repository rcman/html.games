<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spelunker Clone</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --text-color: #333;
            --bg-color: #FFFFFF;
            --ui-bg-color: rgba(0, 0, 0, 0.8);
            --ui-text-color: #FFFFFF;
        }

        .dark {
            --text-color: #EEE;
            --bg-color: #181818;
            --ui-bg-color: rgba(50, 50, 50, 0.8);
            --ui-text-color: #FFFFFF;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            overflow: hidden;
        }

        .game-canvas {
            display: block;
            background-color: #000;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
        }

        .menu-content {
            background-color: var(--ui-bg-color);
            padding: 30px;
            border-radius: 8px;
            max-width: 80%;
            text-align: center;
        }

        .menu h2 {
            font-size: 2rem;
            color: var(--ui-text-color);
            margin-bottom: 20px;
        }

        .game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .game-over h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        .game-over p {
            font-size: 1.5rem;
            margin-bottom: 25px;
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 1.2rem;
            z-index: 5;
            text-shadow: 1px 1px 2px #000;
            display: flex;
            width: calc(100% - 20px);
            justify-content: space-between;
        }

        .oxygen-bar {
            height: 15px;
            width: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            margin-top: 5px;
        }

        .oxygen-fill {
            height: 100%;
            background-color: #00aaff;
            width: 100%;
            transition: width 0.3s linear;
        }

        .score-area {
            text-align: right;
        }

        .touch-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            padding: 0 10px;
            z-index: 5;
        }

        .d-pad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
        }

        .action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            font-size: 24px;
            color: white;
        }

        .action-btn {
            width: 60px;
            height: 60px;
            background-color: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            font-size: 16px;
            color: white;
        }

        .paused-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .instructions {
            margin-top: 20px;
            font-size: 0.9rem;
            color: var(--ui-text-color);
            text-align: left;
            max-width: 100%;
        }

        .instructions h3 {
            text-align: center;
            margin-bottom: 10px;
        }

        .instructions ul {
            list-style-type: none;
            padding: 0 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .level-complete {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 15;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .level-complete h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }

        /* Media Queries for Responsive Design */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2rem;
                margin-bottom: 15px;
            }
            
            .touch-controls {
                display: block;
            }
            
            .instructions {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 1.8rem;
                margin-top: 10px;
            }
            
            .menu-content {
                padding: 15px;
            }
            
            .oxygen-bar {
                width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="game-title">SPELUNKER</div>
    
    <div class="game-container">
        <canvas id="gameCanvas" class="game-canvas" width="640" height="480"></canvas>
        
        <div class="hud">
            <div class="stats-area">
                <div>LIVES: <span id="lives">3</span></div>
                <div>LEVEL: <span id="level">1</span></div>
                <div>OXYGEN</div>
                <div class="oxygen-bar">
                    <div id="oxygenFill" class="oxygen-fill"></div>
                </div>
            </div>
            <div class="score-area">
                <div>SCORE: <span id="score">0</span></div>
                <div>HIGH: <span id="highScore">0</span></div>
                <div>FLARES: <span id="flareCount">3</span></div>
                <div>DYNAMITE: <span id="dynamiteCount">3</span></div>
            </div>
        </div>
        
        <div id="menu" class="menu">
            <div class="menu-content">
                <h2>SPELUNKER</h2>
                <p>The classic cave exploration game</p>
                
                <button id="startGame">Start Game</button>
                
                <div class="instructions">
                    <h3>Controls</h3>
                    <ul>
                        <li>Arrow keys: Move left/right, up/down on ladders</li>
                        <li>Space: Jump</li>
                        <li>Z: Use flare (against ghosts)</li>
                        <li>X: Place dynamite</li>
                        <li>P: Pause game</li>
                        <li>Touch controls available on mobile devices</li>
                    </ul>
                    <h3>Tips</h3>
                    <ul>
                        <li>Be careful of falls - even short ones can be fatal!</li>
                        <li>Manage your oxygen level</li>
                        <li>Use flares to ward off ghosts</li>
                        <li>Collect keys to unlock doors</li>
                        <li>Watch out for steam vents and falling rocks</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div id="gameOver" class="game-over">
            <h2>GAME OVER</h2>
            <p>Score: <span id="finalScore">0</span></p>
            <button id="restartGame">Play Again</button>
        </div>
        
        <div id="levelComplete" class="level-complete">
            <h2>LEVEL COMPLETE!</h2>
            <p>Bonus: <span id="levelBonus">1000</span></p>
            <button id="nextLevel">Next Level</button>
        </div>
        
        <div id="pausedOverlay" class="paused-overlay">
            <h2>PAUSED</h2>
            <button id="resumeGame">Resume</button>
        </div>
        
        <div class="touch-controls">
            <div class="d-pad">
                <div></div>
                <div class="touch-btn" id="upBtn">⬆️</div>
                <div></div>
                <div class="touch-btn" id="leftBtn">⬅️</div>
                <div></div>
                <div class="touch-btn" id="rightBtn">➡️</div>
                <div></div>
                <div class="touch-btn" id="downBtn">⬇️</div>
                <div></div>
            </div>
            <div class="action-buttons">
                <div class="action-btn" id="jumpBtn">JUMP</div>
                <div class="action-btn" id="flareBtn">FLARE</div>
                <div class="action-btn" id="dynamiteBtn">TNT</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="pauseBtn">Pause</button>
        <button id="muteBtn">Mute Sound</button>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game Constants
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 480;
        const TILE_SIZE = 32;
        const GRAVITY = 0.5;
        const PLAYER_WIDTH = 24;
        const PLAYER_HEIGHT = 32;
        const PLAYER_SPEED = 3;
        const JUMP_POWER = 10;
        const LADDER_CLIMB_SPEED = 2;
        const MAX_OXYGEN = 100;
        const OXYGEN_DEPLETION_RATE = 0.05;
        const MAX_FALL_DISTANCE = 64; // Maximum safe fall distance
        
        // Game State
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let highScore = 0;
        let lives = 3;
        let level = 1;
        let oxygen = MAX_OXYGEN;
        let frameCount = 0;
        let muted = false;
        let camera = { x: 0, y: 0 };
        let keys = {};
        let flares = 3;
        let dynamite = 3;
        let playerDeathReason = ""; // For tracking death cause
        
        // AudioContext for sound (initialized on first user interaction)
        let audioCtx = null;
        
        // Get DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure all necessary elements exist before using them
        if (!ctx) {
            console.error("Canvas context could not be created");
        }
        
        function updateUI(id, text) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = text;
            }
        }
        
        // Set actual canvas dimensions based on CSS dimensions to prevent stretching
        function resizeCanvas() {
            if (!canvas) return;
            
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = (containerWidth / CANVAS_WIDTH) * CANVAS_HEIGHT;
            
            // Set canvas display size (CSS pixels)
            canvas.style.width = `${containerWidth}px`;
            canvas.style.height = `${containerHeight}px`;
            
            // Calculate pixel ratio
            const dpr = window.devicePixelRatio || 1;
            
            // Set canvas actual size in memory (scaled for DPI)
            canvas.width = CANVAS_WIDTH * dpr;
            canvas.height = CANVAS_HEIGHT * dpr;
            
            // Scale the context to ensure correct drawing operations
            if (ctx) {
                ctx.scale(dpr, dpr);
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Level 1 - Simple version for testing
        const level1 = {
            width: 800,
            height: 600,
            platforms: [
                // Ground
                { x: 0, y: 400, width: 800, height: 32, type: 'ground' },
                // Mid-level platforms
                { x: 200, y: 300, width: 128, height: 16, type: 'platform' },
                { x: 400, y: 250, width: 96, height: 16, type: 'platform' },
                // Walls
                { x: 0, y: 0, width: 32, height: 600, type: 'wall' },
                { x: 768, y: 0, width: 32, height: 600, type: 'wall' }
            ],
            ladders: [
                { x: 150, y: 300, width: 32, height: 100 }
            ],
            ropes: [
                { x: 500, y: 250, width: 8, height: 150 }
            ],
            doors: [
                { x: 700, y: 368, width: 32, height: 32, locked: true }
            ],
            keys: [
                { x: 450, y: 218, width: 16, height: 16, collected: false }
            ],
            treasures: [
                { x: 300, y: 268, width: 16, height: 16, collected: false }
            ],
            oxygenTanks: [
                { x: 400, y: 218, width: 16, height: 24, collected: false }
            ],
            items: [
                { x: 550, y: 218, width: 16, height: 16, type: 'flare', collected: false }
            ],
            ghosts: [
                { x: 300, y: 330, width: 32, height: 48, direction: 1, speed: 1, scared: false, scaredTimer: 0 }
            ],
            steamVents: [
                { x: 450, y: 380, width: 32, height: 20, active: false, timer: 0, interval: 180, duration: 60 }
            ],
            fallingRocks: [
                { x: 350, y: 100, width: 24, height: 24, falling: false, originalY: 100, timer: 0, triggerX: 340, triggerWidth: 40 }
            ],
            bats: [
                { x: 500, y: 150, width: 24, height: 16, direction: 1, speed: 2, dropTimer: 0, dropInterval: 180 }
            ],
            flares: [],
            dynamites: [],
            explosions: []
        };
        
        // Current level
        let currentLevel = null;
        let batDroppings = [];
        
        // Player object
        const player = {
            x: 100,
            y: 300,
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT,
            velX: 0,
            velY: 0,
            speed: PLAYER_SPEED,
            jumping: false,
            grounded: false,
            climbing: false,
            climbingRope: false,
            facingRight: true,
            dead: false,
            deathTimer: 0,
            fallStartY: 0,
            isFalling: false,
            hasKey: false,
            respawnX: 100,
            respawnY: 300,
            flickerTimer: 0,
            isInvulnerable: false,
            invulnerabilityTimer: 0,
            
            update: function() {
                if (!gameRunning || gamePaused || !currentLevel) return;
                
                if (this.dead) {
                    this.deathTimer--;
                    if (this.deathTimer <= 0) {
                        // Respawn player
                        this.reset();
                    }
                    return;
                }
                
                // Handle invulnerability timer
                if (this.isInvulnerable) {
                    this.invulnerabilityTimer--;
                    this.flickerTimer = (this.flickerTimer + 1) % 8;
                    if (this.invulnerabilityTimer <= 0) {
                        this.isInvulnerable = false;
                    }
                }
                
                // Store previous position for collision detection
                const prevX = this.x;
                const prevY = this.y;
                
                // Reset movement values
                this.velX = 0;
                
                // Handle ladder climbing
                if (this.climbing) {
                    this.velY = 0; // Cancel gravity when on ladder
                    
                    if (keys.up) {
                        this.velY = -LADDER_CLIMB_SPEED;
                    } else if (keys.down) {
                        this.velY = LADDER_CLIMB_SPEED;
                    }
                    
                    // Check if player is still on a ladder
                    let stillOnLadder = false;
                    if (currentLevel && currentLevel.ladders) {
                        for (const ladder of currentLevel.ladders) {
                            if (this.x + this.width > ladder.x && 
                                this.x < ladder.x + ladder.width &&
                                this.y + this.height > ladder.y && 
                                this.y < ladder.y + ladder.height) {
                                stillOnLadder = true;
                                break;
                            }
                        }
                    }
                    
                    if (!stillOnLadder) {
                        this.climbing = false;
                    }
                } else if (this.climbingRope) {
                    // Handle rope climbing
                    this.velY = 0; // Cancel gravity when on rope
                    
                    if (keys.up) {
                        this.velY = -LADDER_CLIMB_SPEED;
                    } else if (keys.down) {
                        this.velY = LADDER_CLIMB_SPEED;
                    }
                    
                    // Check if player is still on a rope
                    let stillOnRope = false;
                    if (currentLevel && currentLevel.ropes) {
                        for (const rope of currentLevel.ropes) {
                            if (this.x + this.width > rope.x && 
                                this.x < rope.x + rope.width &&
                                this.y + this.height > rope.y && 
                                this.y < rope.y + rope.height) {
                                stillOnRope = true;
                                break;
                            }
                        }
                    }
                    
                    if (!stillOnRope) {
                        this.climbingRope = false;
                    }
                } else {
                    // Apply gravity
                    this.velY += GRAVITY;
                    
                    // Track fall distance
                    if (this.velY > 0 && !this.grounded) {
                        if (!this.isFalling) {
                            this.fallStartY = this.y;
                            this.isFalling = true;
                        }
                    } else if (this.grounded) {
                        // Check fall damage when landing
                        if (this.isFalling) {
                            const fallDistance = this.y - this.fallStartY;
                            if (fallDistance > MAX_FALL_DISTANCE) {
                                this.die("fall");
                            }
                            this.isFalling = false;
                        }
                    }
                    
                    // Handle movement
                    if (keys.left) {
                        this.velX = -this.speed;
                        this.facingRight = false;
                    }
                    if (keys.right) {
                        this.velX = this.speed;
                        this.facingRight = true;
                    }
                    
                    // Handle jumping
                    if (keys.jump && this.grounded && !this.jumping) {
                        this.velY = -JUMP_POWER;
                        this.jumping = true;
                        this.grounded = false;
                        playSound('jump');
                    }
                }
                
                // Apply velocity
                this.x += this.velX;
                this.y += this.velY;
                
                // Ensure player doesn't go outside level boundaries
                if (currentLevel) {
                    this.x = Math.max(0, Math.min(this.x, currentLevel.width - this.width));
                }
                
                // Check platform collisions
                this.grounded = false;
                if (currentLevel && currentLevel.platforms) {
                    for (const platform of currentLevel.platforms) {
                        // Skip non-solid decorations
                        if (platform.type === 'decoration') continue;
                        
                        // Check collision
                        if (this.x + this.width > platform.x && 
                            this.x < platform.x + platform.width &&
                            this.y + this.height > platform.y && 
                            this.y < platform.y + platform.height) {
                            
                            // Determine collision side
                            const fromTop = prevY + this.height <= platform.y;
                            const fromBottom = prevY >= platform.y + platform.height;
                            const fromLeft = prevX + this.width <= platform.x;
                            const fromRight = prevX >= platform.x + platform.width;
                            
                            if (fromTop && this.velY >= 0) {
                                // Landing on top of platform
                                this.y = platform.y - this.height;
                                this.velY = 0;
                                this.grounded = true;
                                this.jumping = false;
                            } else if (fromBottom && this.velY < 0) {
                                // Hitting platform from below
                                this.y = platform.y + platform.height;
                                this.velY = 0;
                            } else if (fromLeft && this.velX > 0) {
                                // Hitting platform from left
                                this.x = platform.x - this.width;
                            } else if (fromRight && this.velX < 0) {
                                // Hitting platform from right
                                this.x = platform.x + platform.width;
                            }
                        }
                    }
                }
                
                // Check ladder interactions
                if (currentLevel && currentLevel.ladders) {
                    for (const ladder of currentLevel.ladders) {
                        if (this.x + this.width > ladder.x && 
                            this.x < ladder.x + ladder.width &&
                            this.y + this.height > ladder.y && 
                            this.y < ladder.y + ladder.height) {
                            
                            if ((keys.up || keys.down) && !this.climbing) {
                                // Center player on ladder when starting to climb
                                this.x = ladder.x + (ladder.width - this.width) / 2;
                                this.climbing = true;
                                this.jumping = false;
                            }
                        }
                    }
                }
                
                // Check rope interactions
                if (currentLevel && currentLevel.ropes) {
                    for (const rope of currentLevel.ropes) {
                        if (this.x + this.width > rope.x && 
                            this.x < rope.x + rope.width &&
                            this.y + this.height > rope.y && 
                            this.y < rope.y + rope.height) {
                            
                            if ((keys.up || keys.down) && !this.climbingRope) {
                                // Center player on rope when starting to climb
                                this.x = rope.x + (rope.width - this.width) / 2;
                                this.climbingRope = true;
                                this.jumping = false;
                            }
                        }
                    }
                }
                
                // Check door interactions
                if (currentLevel && currentLevel.doors) {
                    for (let i = 0; i < currentLevel.doors.length; i++) {
                        const door = currentLevel.doors[i];
                        
                        // Check if player is close to door
                        if (this.x + this.width > door.x && 
                            this.x < door.x + door.width &&
                            this.y + this.height > door.y && 
                            this.y < door.y + door.height) {
                            
                            if (door.locked && this.hasKey) {
                                // Unlock the door
                                door.locked = false;
                                this.hasKey = false;
                                playSound('unlock');
                                score += 100;
                                updateHUD();
                            } else if (!door.locked) {
                                // Go through unlocked door - level complete!
                                levelComplete();
                            }
                        }
                    }
                }
                
                // Check key interactions
                if (currentLevel && currentLevel.keys) {
                    for (let i = 0; i < currentLevel.keys.length; i++) {
                        const key = currentLevel.keys[i];
                        
                        if (key.collected) continue;
                        
                        if (this.x + this.width > key.x && 
                            this.x < key.x + key.width &&
                            this.y + this.height > key.y && 
                            this.y < key.y + key.height) {
                            
                            key.collected = true;
                            this.hasKey = true;
                            playSound('collect');
                            score += 200;
                            updateHUD();
                        }
                    }
                }
                
                // Check treasure interactions
                if (currentLevel && currentLevel.treasures) {
                    for (let i = 0; i < currentLevel.treasures.length; i++) {
                        const treasure = currentLevel.treasures[i];
                        
                        if (treasure.collected) continue;
                        
                        if (this.x + this.width > treasure.x && 
                            this.x < treasure.x + treasure.width &&
                            this.y + this.height > treasure.y && 
                            this.y < treasure.y + treasure.height) {
                            
                            treasure.collected = true;
                            playSound('collect');
                            score += 500;
                            updateHUD();
                        }
                    }
                }
                
                // Check oxygen tank interactions
                if (currentLevel && currentLevel.oxygenTanks) {
                    for (let i = 0; i < currentLevel.oxygenTanks.length; i++) {
                        const tank = currentLevel.oxygenTanks[i];
                        
                        if (tank.collected) continue;
                        
                        if (this.x + this.width > tank.x && 
                            this.x < tank.x + tank.width &&
                            this.y + this.height > tank.y && 
                            this.y < tank.y + tank.height) {
                            
                            tank.collected = true;
                            oxygen = Math.min(MAX_OXYGEN, oxygen + 50);
                            playSound('collect');
                            score += 100;
                            updateHUD();
                        }
                    }
                }
                
                // Check item interactions
                if (currentLevel && currentLevel.items) {
                    for (let i = 0; i < currentLevel.items.length; i++) {
                        const item = currentLevel.items[i];
                        
                        if (item.collected) continue;
                        
                        if (this.x + this.width > item.x && 
                            this.x < item.x + item.width &&
                            this.y + this.height > item.y && 
                            this.y < item.y + item.height) {
                            
                            item.collected = true;
                            
                            if (item.type === 'flare') {
                                flares++;
                                playSound('collect');
                                score += 50;
                            } else if (item.type === 'dynamite') {
                                dynamite++;
                                playSound('collect');
                                score += 75;
                            }
                            
                            updateHUD();
                        }
                    }
                }
                
                // Check hazard interactions
                if (!this.isInvulnerable) {
                    // Check ghost collisions
                    if (currentLevel && currentLevel.ghosts) {
                        for (const ghost of currentLevel.ghosts) {
                            if (this.x + this.width > ghost.x && 
                                this.x < ghost.x + ghost.width &&
                                this.y + this.height > ghost.y && 
                                this.y < ghost.y + ghost.height) {
                                
                                this.die("ghost");
                                break;
                            }
                        }
                    }
                    
                    // Check steam vent collisions
                    if (currentLevel && currentLevel.steamVents) {
                        for (const vent of currentLevel.steamVents) {
                            if (vent.active && 
                                this.x + this.width > vent.x && 
                                this.x < vent.x + vent.width &&
                                this.y + this.height > vent.y && 
                                this.y < vent.y + vent.height) {
                                
                                this.die("steam");
                                break;
                            }
                        }
                    }
                    
                    // Check falling rock collisions
                    if (currentLevel && currentLevel.fallingRocks) {
                        for (const rock of currentLevel.fallingRocks) {
                            if (rock.falling && 
                                this.x + this.width > rock.x && 
                                this.x < rock.x + rock.width &&
                                this.y + this.height > rock.y && 
                                this.y < rock.y + rock.height) {
                                
                                this.die("rock");
                                break;
                            }
                        }
                    }
                    
                    // Check bat droppings
                    for (const dropping of batDroppings) {
                        if (this.x + this.width > dropping.x && 
                            this.x < dropping.x + dropping.width &&
                            this.y + this.height > dropping.y && 
                            this.y < dropping.y + dropping.height) {
                            
                            this.die("bat");
                            break;
                        }
                    }
                }
                
                // Check if player fell out of the level
                if (currentLevel && this.y > currentLevel.height) {
                    this.die("fall");
                }
                
                // Update camera to follow player
                camera.x = this.x - CANVAS_WIDTH / 2;
                camera.y = this.y - CANVAS_HEIGHT / 2;
                
                // Keep camera within level bounds
                if (currentLevel) {
                    camera.x = Math.max(0, Math.min(camera.x, currentLevel.width - CANVAS_WIDTH));
                    camera.y = Math.max(0, Math.min(camera.y, currentLevel.height - CANVAS_HEIGHT));
                }
                
                // Deplete oxygen
                oxygen -= OXYGEN_DEPLETION_RATE;
                if (oxygen <= 0) {
                    oxygen = 0;
                    this.die("oxygen");
                }
                
                updateHUD();
            },
            
            draw: function() {
                if (!ctx) return;
                
                if (this.dead) {
                    // Draw death animation
                    ctx.fillStyle = '#FF4444';
                    ctx.fillRect(
                        this.x - camera.x, 
                        this.y - camera.y, 
                        this.width, 
                        this.height
                    );
                    return;
                }
                
                // Skip drawing every few frames during invulnerability for flicker effect
                if (this.isInvulnerable && this.flickerTimer < 4) {
                    return;
                }
                
                // Draw player
                if (this.climbing || this.climbingRope) {
                    // Climbing animation
                    ctx.fillStyle = '#5D5CDE';
                    ctx.fillRect(
                        this.x - camera.x, 
                        this.y - camera.y, 
                        this.width, 
                        this.height
                    );
                    
                    // Draw climbing details
                    ctx.fillStyle = '#000';
                    ctx.fillRect(
                        this.x - camera.x + 5, 
                        this.y - camera.y + 8 + (frameCount % 20 < 10 ? 2 : 0), 
                        this.width - 10, 
                        3
                    );
                    ctx.fillRect(
                        this.x - camera.x + 5, 
                        this.y - camera.y + 18 + (frameCount % 20 < 10 ? 0 : 2), 
                        this.width - 10, 
                        3
                    );
                } else {
                    // Normal walking/jumping animation
                    ctx.fillStyle = '#5D5CDE';
                    ctx.fillRect(
                        this.x - camera.x, 
                        this.y - camera.y, 
                        this.width, 
                        this.height
                    );
                    
                    // Draw hat
                    ctx.fillStyle = '#333';
                    ctx.fillRect(
                        this.x - camera.x + 2, 
                        this.y - camera.y, 
                        this.width - 4, 
                        5
                    );
                    
                    // Draw face direction
                    if (this.facingRight) {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(
                            this.x - camera.x + this.width - 10, 
                            this.y - camera.y + 8, 
                            4, 
                            4
                        );
                    } else {
                        ctx.fillStyle = '#FFF';
                        ctx.fillRect(
                            this.x - camera.x + 6, 
                            this.y - camera.y + 8, 
                            4, 
                            4
                        );
                    }
                    
                    // Draw legs with walking animation
                    if (this.grounded && (this.velX !== 0)) {
                        // Walking animation
                        const legOffset = frameCount % 20 < 10 ? 3 : -3;
                        
                        ctx.fillStyle = '#333';
                        ctx.fillRect(
                            this.x - camera.x + 6, 
                            this.y - camera.y + this.height - 10, 
                            4, 
                            10 + legOffset
                        );
                        ctx.fillRect(
                            this.x - camera.x + this.width - 10, 
                            this.y - camera.y + this.height - 10, 
                            4, 
                            10 - legOffset
                        );
                    } else {
                        // Standing or jumping
                        ctx.fillStyle = '#333';
                        ctx.fillRect(
                            this.x - camera.x + 6, 
                            this.y - camera.y + this.height - 10, 
                            4, 
                            10
                        );
                        ctx.fillRect(
                            this.x - camera.x + this.width - 10, 
                            this.y - camera.y + this.height - 10, 
                            4, 
                            10
                        );
                    }
                }
                
                // Draw key if player has one
                if (this.hasKey) {
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(
                        this.x - camera.x + this.width / 2 - 2, 
                        this.y - camera.y - 8, 
                        4, 
                        8
                    );
                    ctx.fillRect(
                        this.x - camera.x + this.width / 2 - 6, 
                        this.y - camera.y - 6, 
                        12, 
                        4
                    );
                }
            },
            
            die: function(reason) {
                if (this.dead) return;
                
                this.dead = true;
                this.deathTimer = 120; // 2 seconds at 60 FPS
                playerDeathReason = reason;
                
                // Play appropriate death sound
                if (reason === "fall") {
                    playSound('fall');
                } else if (reason === "ghost") {
                    playSound('ghostDeath');
                } else if (reason === "steam") {
                    playSound('steamDeath');
                } else if (reason === "rock") {
                    playSound('rockDeath');
                } else if (reason === "bat") {
                    playSound('batDeath');
                } else if (reason === "oxygen") {
                    playSound('oxygenDeath');
                } else {
                    playSound('death');
                }
                
                lives--;
                updateHUD();
                
                if (lives <= 0) {
                    // Game over
                    gameOver();
                }
            },
            
            reset: function() {
                this.x = this.respawnX;
                this.y = this.respawnY;
                this.velX = 0;
                this.velY = 0;
                this.grounded = false;
                this.jumping = false;
                this.climbing = false;
                this.climbingRope = false;
                this.dead = false;
                this.isFalling = false;
                
                // Brief invulnerability after respawn
                this.isInvulnerable = true;
                this.invulnerabilityTimer = 120; // 2 seconds
                
                // Restore some oxygen
                oxygen = Math.max(oxygen, MAX_OXYGEN * 0.3);
                updateHUD();
            },
            
            useFlare: function() {
                if (flares <= 0 || this.dead || !currentLevel) return;
                
                flares--;
                updateHUD();
                
                // Create flare effect
                if (currentLevel.flares) {
                    currentLevel.flares.push({
                        x: this.x + (this.facingRight ? this.width : -80),
                        y: this.y,
                        width: 80,
                        height: 40,
                        duration: 180 // 3 seconds
                    });
                }
                
                playSound('flare');
                
                // Check if any ghosts are affected
                if (currentLevel.ghosts) {
                    for (const ghost of currentLevel.ghosts) {
                        // Only affect ghosts in front of player
                        if ((this.facingRight && ghost.x > this.x) ||
                            (!this.facingRight && ghost.x < this.x)) {
                            
                            // Check horizontal distance
                            const distX = Math.abs(ghost.x - this.x);
                            if (distX < 200) {
                                // Scared ghost - reverse direction
                                ghost.direction *= -1;
                                ghost.scared = true;
                                ghost.scaredTimer = 120; // 2 seconds
                            }
                        }
                    }
                }
            },
            
            placeDynamite: function() {
                if (dynamite <= 0 || this.dead || !currentLevel) return;
                
                dynamite--;
                updateHUD();
                
                // Create dynamite
                if (currentLevel.dynamites) {
                    currentLevel.dynamites.push({
                        x: this.x,
                        y: this.y + this.height - 10,
                        width: 10,
                        height: 10,
                        timer: 180, // 3 seconds until explosion
                        exploded: false
                    });
                }
                
                playSound('placeDynamite');
            }
        };
        
        // Initialize level
        function initLevel() {
            // Make a deep copy of level1 to start
            currentLevel = JSON.parse(JSON.stringify(level1));
            
            // Initialize bat droppings
            batDroppings = [];
            
            // Set player position at level start
            player.x = 100;
            player.y = 300;
            player.respawnX = 100;
            player.respawnY = 300;
            player.velX = 0;
            player.velY = 0;
            player.jumping = false;
            player.climbing = false;
            player.climbingRope = false;
            player.grounded = false;
            player.dead = false;
            player.isInvulnerable = true;
            player.invulnerabilityTimer = 120; // 2 seconds of invulnerability at level start
            
            // Replenish oxygen
            oxygen = MAX_OXYGEN;
            
            // Reset camera
            camera.x = 0;
            camera.y = 0;
            
            updateHUD();
        }
        
        // Level management
        function updateLevel() {
            if (!gameRunning || gamePaused || !currentLevel) return;
            
            // Update ghosts
            if (currentLevel.ghosts) {
                for (let i = 0; i < currentLevel.ghosts.length; i++) {
                    const ghost = currentLevel.ghosts[i];
                    
                    // Move ghost
                    ghost.x += ghost.direction * (ghost.scared ? ghost.speed * 1.5 : ghost.speed);
                    
                    // Bounce ghosts off boundaries or platforms
                    let shouldBounce = false;
                    
                    // Check if ghost hits a wall
                    if (ghost.x < 0 || ghost.x + ghost.width > currentLevel.width) {
                        shouldBounce = true;
                    }
                    
                    // Check if ghost encounters a wall platform
                    if (currentLevel.platforms) {
                        for (const platform of currentLevel.platforms) {
                            if (platform.type === 'wall' &&
                                ghost.x + ghost.width > platform.x &&
                                ghost.x < platform.x + platform.width &&
                                ghost.y + ghost.height > platform.y &&
                                ghost.y < platform.y + platform.height) {
                                shouldBounce = true;
                                break;
                            }
                        }
                    }
                    
                    if (shouldBounce) {
                        ghost.direction *= -1;
                    }
                    
                    // Update scared timer
                    if (ghost.scared) {
                        ghost.scaredTimer--;
                        if (ghost.scaredTimer <= 0) {
                            ghost.scared = false;
                        }
                    }
                }
            }
            
            // Update steam vents
            if (currentLevel.steamVents) {
                for (let i = 0; i < currentLevel.steamVents.length; i++) {
                    const vent = currentLevel.steamVents[i];
                    
                    vent.timer++;
                    
                    if (!vent.active && vent.timer >= vent.interval) {
                        // Activate vent
                        vent.active = true;
                        vent.timer = 0;
                        playSound('steam');
                    } else if (vent.active && vent.timer >= vent.duration) {
                        // Deactivate vent
                        vent.active = false;
                        vent.timer = 0;
                    }
                }
            }
            
            // Update falling rocks
            if (currentLevel.fallingRocks) {
                for (let i = 0; i < currentLevel.fallingRocks.length; i++) {
                    const rock = currentLevel.fallingRocks[i];
                    
                    // Ensure originalY is set
                    if (rock.originalY === undefined) {
                        rock.originalY = rock.y;
                    }
                    
                    if (!rock.falling) {
                        // Check if player is under rock to trigger fall
                        if (player.x + player.width > rock.triggerX &&
                            player.x < rock.triggerX + rock.triggerWidth &&
                            player.y > rock.y) {
                            rock.falling = true;
                            playSound('rockFall');
                        }
                    } else {
                        // Update falling rock position
                        rock.y += 5;
                        rock.timer++;
                        
                        // Check if rock hits ground
                        let hitGround = false;
                        
                        if (currentLevel.platforms) {
                            for (const platform of currentLevel.platforms) {
                                if (rock.y + rock.height > platform.y &&
                                    rock.y < platform.y + platform.height &&
                                    rock.x + rock.width > platform.x &&
                                    rock.x < platform.x + platform.width) {
                                    hitGround = true;
                                    break;
                                }
                            }
                        }
                        
                        // Remove rock after it hits ground or falls out of level
                        if (hitGround || rock.y > currentLevel.height) {
                            rock.falling = false;
                            rock.y = rock.originalY; // Reset to original position
                            rock.timer = 0;
                        }
                    }
                }
            }
            
            // Update bats
            if (currentLevel.bats) {
                for (let i = 0; i < currentLevel.bats.length; i++) {
                    const bat = currentLevel.bats[i];
                    
                    // Move bat horizontally
                    bat.x += bat.direction * bat.speed;
                    
                    // Bounce bat off boundaries
                    if (bat.x < 0 || bat.x + bat.width > currentLevel.width) {
                        bat.direction *= -1;
                    }
                    
                    // Update dropping timer
                    bat.dropTimer++;
                    
                    // Create dropping when timer expires
                    if (bat.dropTimer >= bat.dropInterval) {
                        bat.dropTimer = 0;
                        
                        // Only drop when player is nearby
                        const distToPlayer = Math.abs(bat.x - player.x);
                        if (distToPlayer < 200) {
                            batDroppings.push({
                                x: bat.x + bat.width / 2,
                                y: bat.y + bat.height,
                                width: 6,
                                height: 6,
                                velY: 3
                            });
                        }
                    }
                }
            }
            
            // Update bat droppings
            for (let i = batDroppings.length - 1; i >= 0; i--) {
                const dropping = batDroppings[i];
                
                // Move dropping down
                dropping.y += dropping.velY;
                
                // Check if dropping hits ground
                let hitGround = false;
                
                if (currentLevel.platforms) {
                    for (const platform of currentLevel.platforms) {
                        if (dropping.y + dropping.height > platform.y &&
                            dropping.y < platform.y + platform.height &&
                            dropping.x + dropping.width > platform.x &&
                            dropping.x < platform.x + platform.width) {
                            hitGround = true;
                            break;
                        }
                    }
                }
                
                // Remove dropping if it hits ground or goes off-screen
                if (hitGround || dropping.y > currentLevel.height) {
                    batDroppings.splice(i, 1);
                }
            }
            
            // Update flares
            if (currentLevel.flares) {
                for (let i = currentLevel.flares.length - 1; i >= 0; i--) {
                    const flare = currentLevel.flares[i];
                    
                    flare.duration--;
                    
                    if (flare.duration <= 0) {
                        currentLevel.flares.splice(i, 1);
                    }
                }
            }
            
            // Update dynamites
            if (currentLevel.dynamites) {
                for (let i = currentLevel.dynamites.length - 1; i >= 0; i--) {
                    const dynamite = currentLevel.dynamites[i];
                    
                    if (!dynamite.exploded) {
                        dynamite.timer--;
                        
                        if (dynamite.timer <= 0) {
                            // Explode dynamite
                            dynamite.exploded = true;
                            
                            // Create explosion
                            if (currentLevel.explosions) {
                                currentLevel.explosions.push({
                                    x: dynamite.x - 40,
                                    y: dynamite.y - 40,
                                    width: 80,
                                    height: 80,
                                    duration: 30
                                });
                            }
                            
                            playSound('explosion');
                            
                            // Check if explosion hits any ghosts
                            if (currentLevel.ghosts) {
                                for (let j = currentLevel.ghosts.length - 1; j >= 0; j--) {
                                    const ghost = currentLevel.ghosts[j];
                                    const distX = Math.abs((ghost.x + ghost.width / 2) - (dynamite.x + dynamite.width / 2));
                                    const distY = Math.abs((ghost.y + ghost.height / 2) - (dynamite.y + dynamite.height / 2));
                                    
                                    if (distX < 60 && distY < 60) {
                                        // Remove ghost and add score
                                        currentLevel.ghosts.splice(j, 1);
                                        score += 200;
                                        updateHUD();
                                    }
                                }
                            }
                        }
                    } else {
                        // Remove exploded dynamite after explosion animation finishes
                        currentLevel.dynamites.splice(i, 1);
                    }
                }
            }
            
            // Update explosions
            if (currentLevel.explosions) {
                for (let i = currentLevel.explosions.length - 1; i >= 0; i--) {
                    const explosion = currentLevel.explosions[i];
                    
                    explosion.duration--;
                    
                    if (explosion.duration <= 0) {
                        currentLevel.explosions.splice(i, 1);
                    }
                }
            }
        }
        
        function drawLevel() {
            if (!ctx || !currentLevel) return;
            
            // Clear canvas with background color (dark cave color)
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw platforms
            if (currentLevel.platforms) {
                for (const platform of currentLevel.platforms) {
                    // Skip if platform is completely outside of view
                    if (platform.x + platform.width < camera.x || 
                        platform.x > camera.x + CANVAS_WIDTH || 
                        platform.y + platform.height < camera.y || 
                        platform.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    if (platform.type === 'ground') {
                        ctx.fillStyle = '#553300';
                    } else if (platform.type === 'platform') {
                        ctx.fillStyle = '#775533';
                    } else if (platform.type === 'wall') {
                        ctx.fillStyle = '#444444';
                    } else {
                        ctx.fillStyle = '#555555';
                    }
                    
                    ctx.fillRect(
                        platform.x - camera.x, 
                        platform.y - camera.y, 
                        platform.width, 
                        platform.height
                    );
                }
            }
            
            // Draw ladders
            if (currentLevel.ladders) {
                for (const ladder of currentLevel.ladders) {
                    // Skip if ladder is completely outside of view
                    if (ladder.x + ladder.width < camera.x || 
                        ladder.x > camera.x + CANVAS_WIDTH || 
                        ladder.y + ladder.height < camera.y || 
                        ladder.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.fillStyle = '#AA7744';
                    
                    // Draw ladder sides
                    ctx.fillRect(
                        ladder.x - camera.x, 
                        ladder.y - camera.y, 
                        4, 
                        ladder.height
                    );
                    
                    ctx.fillRect(
                        ladder.x - camera.x + ladder.width - 4, 
                        ladder.y - camera.y, 
                        4, 
                        ladder.height
                    );
                    
                    // Draw ladder rungs
                    for (let y = 0; y < ladder.height; y += 16) {
                        ctx.fillRect(
                            ladder.x - camera.x, 
                            ladder.y - camera.y + y, 
                            ladder.width, 
                            4
                        );
                    }
                }
            }
            
            // Draw ropes
            if (currentLevel.ropes) {
                for (const rope of currentLevel.ropes) {
                    // Skip if rope is completely outside of view
                    if (rope.x + rope.width < camera.x || 
                        rope.x > camera.x + CANVAS_WIDTH || 
                        rope.y + rope.height < camera.y || 
                        rope.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.strokeStyle = '#DDAA77';
                    ctx.lineWidth = rope.width;
                    
                    // Draw wavy rope
                    ctx.beginPath();
                    ctx.moveTo(rope.x - camera.x + rope.width / 2, rope.y - camera.y);
                    
                    for (let y = 0; y < rope.height; y += 20) {
                        const wobble = Math.sin(frameCount * 0.05 + y * 0.1) * 5;
                        ctx.lineTo(
                            rope.x - camera.x + rope.width / 2 + wobble, 
                            rope.y - camera.y + y + 10
                        );
                        ctx.lineTo(
                            rope.x - camera.x + rope.width / 2 - wobble, 
                            rope.y - camera.y + y + 20
                        );
                    }
                    
                    ctx.stroke();
                }
            }
            
            // Draw doors
            if (currentLevel.doors) {
                for (const door of currentLevel.doors) {
                    // Skip if door is completely outside of view
                    if (door.x + door.width < camera.x || 
                        door.x > camera.x + CANVAS_WIDTH || 
                        door.y + door.height < camera.y || 
                        door.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    if (door.locked) {
                        ctx.fillStyle = '#885533';
                    } else {
                        ctx.fillStyle = '#44AA33';
                    }
                    
                    ctx.fillRect(
                        door.x - camera.x, 
                        door.y - camera.y, 
                        door.width, 
                        door.height
                    );
                    
                    // Draw door handle
                    ctx.fillStyle = door.locked ? '#FFD700' : '#AABBCC';
                    ctx.fillRect(
                        door.x - camera.x + door.width - 10, 
                        door.y - camera.y + door.height / 2 - 3, 
                        6, 
                        6
                    );
                }
            }
            
            // Draw keys
            if (currentLevel.keys) {
                for (const key of currentLevel.keys) {
                    if (key.collected) continue;
                    
                    // Skip if key is completely outside of view
                    if (key.x + key.width < camera.x || 
                        key.x > camera.x + CANVAS_WIDTH || 
                        key.y + key.height < camera.y || 
                        key.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(
                        key.x - camera.x, 
                        key.y - camera.y, 
                        key.width, 
                        key.height
                    );
                    
                    // Draw key details
                    ctx.fillRect(
                        key.x - camera.x + key.width / 2 - 1, 
                        key.y - camera.y, 
                        2, 
                        8
                    );
                    ctx.fillRect(
                        key.x - camera.x + key.width / 2 - 4, 
                        key.y - camera.y + 4, 
                        8, 
                        3
                    );
                }
            }
            
            // Draw treasures
            if (currentLevel.treasures) {
                for (const treasure of currentLevel.treasures) {
                    if (treasure.collected) continue;
                    
                    // Skip if treasure is completely outside of view
                    if (treasure.x + treasure.width < camera.x || 
                        treasure.x > camera.x + CANVAS_WIDTH || 
                        treasure.y + treasure.height < camera.y || 
                        treasure.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.fillStyle = '#FFA500';
                    ctx.fillRect(
                        treasure.x - camera.x, 
                        treasure.y - camera.y, 
                        treasure.width, 
                        treasure.height
                    );
                }
            }
            
            // Draw oxygen tanks
            if (currentLevel.oxygenTanks) {
                for (const tank of currentLevel.oxygenTanks) {
                    if (tank.collected) continue;
                    
                    // Skip if tank is completely outside of view
                    if (tank.x + tank.width < camera.x || 
                        tank.x > camera.x + CANVAS_WIDTH || 
                        tank.y + tank.height < camera.y || 
                        tank.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.fillStyle = '#00AAFF';
                    ctx.fillRect(
                        tank.x - camera.x, 
                        tank.y - camera.y, 
                        tank.width, 
                        tank.height
                    );
                }
            }
            
            // Draw items (flares and dynamite)
            if (currentLevel.items) {
                for (const item of currentLevel.items) {
                    if (item.collected) continue;
                    
                    // Skip if item is completely outside of view
                    if (item.x + item.width < camera.x || 
                        item.x > camera.x + CANVAS_WIDTH || 
                        item.y + item.height < camera.y || 
                        item.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    if (item.type === 'flare') {
                        ctx.fillStyle = '#FF6633';
                        ctx.fillRect(
                            item.x - camera.x, 
                            item.y - camera.y, 
                            item.width, 
                            item.height
                        );
                    } else if (item.type === 'dynamite') {
                        ctx.fillStyle = '#CC0000';
                        ctx.fillRect(
                            item.x - camera.x, 
                            item.y - camera.y, 
                            item.width, 
                            item.height
                        );
                    }
                }
            }
            
            // Draw ghosts
            if (currentLevel.ghosts) {
                for (const ghost of currentLevel.ghosts) {
                    // Skip if ghost is completely outside of view
                    if (ghost.x + ghost.width < camera.x || 
                        ghost.x > camera.x + CANVAS_WIDTH || 
                        ghost.y + ghost.height < camera.y || 
                        ghost.y > camera.y + CANVAS_HEIGHT) {
                        continue;
                    }
                    
                    ctx.fillStyle = ghost.scared ? '#AAAAFF' : '#EEEEFF';
                    
                    // Draw ghost body
                    ctx.fillRect(
                        ghost.x - camera.x, 
                        ghost.y - camera.y, 
                        ghost.width, 
                        ghost.height
                    );
                }
            }
            
            // Draw player
            player.draw();
        }
        
        // Level completion
        function levelComplete() {
            // Calculate bonus points
            const oxygenBonus = Math.floor(oxygen) * 10;
            const treasureBonus = 1000;
            const levelBonus = level * 1000;
            const totalBonus = oxygenBonus + treasureBonus + levelBonus;
            
            // Add bonus to score
            score += totalBonus;
            
            // Show level complete overlay
            updateUI('levelBonus', totalBonus);
            const levelCompleteElement = document.getElementById('levelComplete');
            if (levelCompleteElement) {
                levelCompleteElement.style.display = 'flex';
            }
            
            // Play level complete sound
            playSound('levelComplete');
            
            gameRunning = false;
        }
        
        // Game over function
        function gameOver() {
            gameRunning = false;
            
            // Show game over screen
            const gameOverElement = document.getElementById('gameOver');
            if (gameOverElement) {
                const titleElement = gameOverElement.querySelector('h2');
                if (titleElement) {
                    titleElement.textContent = 'GAME OVER';
                }
                updateUI('finalScore', score);
                gameOverElement.style.display = 'flex';
            }
            
            // Check for high score
            if (score > highScore) {
                highScore = score;
                try {
                    localStorage.setItem('spelunkerHighScore', highScore);
                } catch (e) {
                    console.log("Could not save high score:", e);
                }
            }
            
            // Play game over sound
            playSound('gameOver');
        }
        
        // Create audio context on first user interaction (to comply with browser policies)
        function initAudio() {
            if (!audioCtx && window.AudioContext || window.webkitAudioContext) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log("Could not create audio context:", e);
                }
            }
        }
        
        // Sound effects
        function playSound(name) {
            if (muted || !audioCtx) return;
            
            try {
                // Create oscillator for sound
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                // Set sound properties based on name
                if (name === 'jump') {
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                } else if (name === 'collect') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                } else if (name === 'death' || name === 'fall' || name === 'ghostDeath' || 
                        name === 'steamDeath' || name === 'rockDeath' || name === 'batDeath' || 
                        name === 'oxygenDeath') {
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.3);
                } else if (name === 'explosion') {
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.6, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                } else if (name === 'flare') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                } else if (name === 'placeDynamite') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                } else if (name === 'steam') {
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.5);
                } else if (name === 'rockFall') {
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                } else if (name === 'unlock') {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.2);
                } else if (name === 'levelComplete') {
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(330, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(392, audioCtx.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime + 0.4);
                    oscillator.frequency.setValueAtTime(494, audioCtx.currentTime + 0.6);
                    oscillator.frequency.setValueAtTime(523, audioCtx.currentTime + 0.8);
                    gainNode.gain.setValueAtTime(0.6, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.6, audioCtx.currentTime + 0.9);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 1.0);
                } else if (name === 'gameOver') {
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(392, audioCtx.currentTime + 0.2);
                    oscillator.frequency.setValueAtTime(349, audioCtx.currentTime + 0.4);
                    oscillator.frequency.setValueAtTime(330, audioCtx.currentTime + 0.6);
                    oscillator.frequency.setValueAtTime(293, audioCtx.currentTime + 0.8);
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime + 0.9);
                    gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1.0);
                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 1.0);
                }
            } catch (e) {
                console.log("Error playing sound:", e);
            }
        }
        
        // Control state
        keys = {
            left: false,
            right: false,
            up: false,
            down: false,
            jump: false,
            flare: false,
            dynamite: false
        };
        
        // Keyboard controls
        window.addEventListener('keydown', function(e) {
            initAudio(); // Initialize audio on first interaction
            
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp') keys.up = true;
            if (e.key === 'ArrowDown') keys.down = true;
            if (e.key === ' ') keys.jump = true;
            if (e.key === 'z' || e.key === 'Z') {
                if (!keys.flare) {
                    keys.flare = true;
                    player.useFlare();
                }
            }
            if (e.key === 'x' || e.key === 'X') {
                if (!keys.dynamite) {
                    keys.dynamite = true;
                    player.placeDynamite();
                }
            }
            
            // Pause game with 'p'
            if (e.key === 'p' && gameRunning) {
                togglePause();
            }
        });
        
        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === ' ') keys.jump = false;
            if (e.key === 'z' || e.key === 'Z') keys.flare = false;
            if (e.key === 'x' || e.key === 'X') keys.dynamite = false;
        });
        
        // Touch controls
        function setupTouchControls() {
            const elements = {
                leftBtn: document.getElementById('leftBtn'),
                rightBtn: document.getElementById('rightBtn'),
                upBtn: document.getElementById('upBtn'),
                downBtn: document.getElementById('downBtn'),
                jumpBtn: document.getElementById('jumpBtn'),
                flareBtn: document.getElementById('flareBtn'),
                dynamiteBtn: document.getElementById('dynamiteBtn')
            };
            
            // Setup event listeners only if elements exist
            if (elements.leftBtn) {
                elements.leftBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    keys.left = true;
                });
                elements.leftBtn.addEventListener('touchend', function() {
                    keys.left = false;
                });
            }
            
            if (elements.rightBtn) {
                elements.rightBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    keys.right = true;
                });
                elements.rightBtn.addEventListener('touchend', function() {
                    keys.right = false;
                });
            }
            
            if (elements.upBtn) {
                elements.upBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    keys.up = true;
                });
                elements.upBtn.addEventListener('touchend', function() {
                    keys.up = false;
                });
            }
            
            if (elements.downBtn) {
                elements.downBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    keys.down = true;
                });
                elements.downBtn.addEventListener('touchend', function() {
                    keys.down = false;
                });
            }
            
            if (elements.jumpBtn) {
                elements.jumpBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    keys.jump = true;
                });
                elements.jumpBtn.addEventListener('touchend', function() {
                    keys.jump = false;
                });
            }
            
            if (elements.flareBtn) {
                elements.flareBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    player.useFlare();
                });
            }
            
            if (elements.dynamiteBtn) {
                elements.dynamiteBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    initAudio();
                    player.placeDynamite();
                });
            }
        }
        
        // UI Controls
        function setupUIControls() {
            const elements = {
                startGame: document.getElementById('startGame'),
                restartGame: document.getElementById('restartGame'),
                nextLevel: document.getElementById('nextLevel'),
                pauseBtn: document.getElementById('pauseBtn'),
                resumeGame: document.getElementById('resumeGame'),
                muteBtn: document.getElementById('muteBtn')
            };
            
            if (elements.startGame) {
                elements.startGame.addEventListener('click', startGame);
            }
            
            if (elements.restartGame) {
                elements.restartGame.addEventListener('click', restartGame);
            }
            
            if (elements.nextLevel) {
                elements.nextLevel.addEventListener('click', function() {
                    // For simplicity in this demo, just restart the game
                    restartGame();
                });
            }
            
            if (elements.pauseBtn) {
                elements.pauseBtn.addEventListener('click', togglePause);
            }
            
            if (elements.resumeGame) {
                elements.resumeGame.addEventListener('click', togglePause);
            }
            
            if (elements.muteBtn) {
                elements.muteBtn.addEventListener('click', toggleMute);
            }
        }
        
        function startGame() {
            try {
                initAudio(); // Initialize audio context
                
                // Load high score from local storage
                try {
                    const savedHighScore = localStorage.getItem('spelunkerHighScore');
                    if (savedHighScore) {
                        highScore = parseInt(savedHighScore);
                    }
                } catch (e) {
                    console.log("Could not load high score:", e);
                }
                
                // Reset game stats
                score = 0;
                lives = 3;
                level = 1;
                frameCount = 0;
                oxygen = MAX_OXYGEN;
                flares = 3;
                dynamite = 3;
                
                // Initialize first level
                initLevel();
                
                // Hide menu
                const menuElement = document.getElementById('menu');
                const gameOverElement = document.getElementById('gameOver');
                
                if (menuElement) menuElement.style.display = 'none';
                if (gameOverElement) gameOverElement.style.display = 'none';
                
                gameRunning = true;
                gamePaused = false;
                
                updateHUD();
            } catch (e) {
                console.error("Error starting game:", e);
            }
        }
        
        function restartGame() {
            const gameOverElement = document.getElementById('gameOver');
            const menuElement = document.getElementById('menu');
            
            if (gameOverElement) gameOverElement.style.display = 'none';
            if (menuElement) menuElement.style.display = 'flex';
        }
        
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            
            const pausedOverlayElement = document.getElementById('pausedOverlay');
            const pauseBtnElement = document.getElementById('pauseBtn');
            
            if (pausedOverlayElement) {
                pausedOverlayElement.style.display = gamePaused ? 'flex' : 'none';
            }
            
            if (pauseBtnElement) {
                pauseBtnElement.textContent = gamePaused ? 'Resume' : 'Pause';
            }
        }
        
        function toggleMute() {
            muted = !muted;
            
            const muteBtnElement = document.getElementById('muteBtn');
            if (muteBtnElement) {
                muteBtnElement.textContent = muted ? 'Unmute Sound' : 'Mute Sound';
            }
        }
        
        // Update the HUD
        function updateHUD() {
            updateUI('score', score);
            updateUI('highScore', highScore);
            updateUI('lives', lives);
            updateUI('level', level);
            updateUI('flareCount', flares);
            updateUI('dynamiteCount', dynamite);
            
            // Update oxygen bar
            const oxygenFillElement = document.getElementById('oxygenFill');
            if (oxygenFillElement) {
                const oxygenPercent = (oxygen / MAX_OXYGEN) * 100;
                oxygenFillElement.style.width = `${oxygenPercent}%`;
                
                // Change oxygen bar color based on level
                if (oxygenPercent > 60) {
                    oxygenFillElement.style.backgroundColor = '#00AAFF';
                } else if (oxygenPercent > 30) {
                    oxygenFillElement.style.backgroundColor = '#FFAA00';
                } else {
                    oxygenFillElement.style.backgroundColor = '#FF0000';
                }
            }
        }
        
        // Game loop
        function gameLoop() {
            try {
                // Update game state
                if (gameRunning) {
                    player.update();
                    updateLevel();
                    
                    if (!gamePaused) {
                        frameCount++;
                    }
                }
                
                // Draw game
                drawLevel();
                
                // Request next frame
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("Error in game loop:", e);
            }
        }
        
        // Initialize and start game
        try {
            // Setup touch and UI controls
            setupTouchControls();
            setupUIControls();
            
            // Try to load high score
            try {
                const savedHighScore = localStorage.getItem('spelunkerHighScore');
                if (savedHighScore) {
                    highScore = parseInt(savedHighScore);
                }
            } catch (e) {
                console.log("Could not load high score:", e);
            }
            
            updateHUD();
            gameLoop();
        } catch (e) {
            console.error("Error initializing game:", e);
        }
    </script>
</body>
</html>